[section Output Iterator Adaptors]

Output Iterator Adaptors adapt the behavior of the underlying iterator.
An Output Iterator Adaptor is a _pipable_object_, so that, by using `operator|=`, you can "chain" multiple adaptors:

    int const in[] = { 1,2,3,4,5,6,7,8,9,10 };
    int const answer[] = {2*3,4*3,6*3,8*3,10*3};
    std::vector<int> out;
    copy(in, filterer(regular(bll::_1 % 2 == 0))
        |= transformer(regular(bll::_1 * 3)) |= std::back_inserter(out) );
    BOOST_CHECK( equals(out, answer) );




[section converter]

[h3 Description]
`converter` changes an output to specified type.

[h3 Header]
* `<pstade/oven/converter.hpp>`

[h3 Model of]
* ...

[h3 Notation]
* `f_` is an imaginary _function_object_ which behaves as if it were `v -> *x++ = boost::implicit_cast<To>(v)`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`xp_make_converter<To>`]
        [
            A _bindable_ _deferred_callable_object_ type
        ]
    ]
    [
        [`xp_make_converter<To>()(x)`]
        [
            `applier(f_)`
        ]
    ]
    [
        [`oven::make_converter<To>(x)`]
        [
            `xp_make_converter<To>()(x)`
        ]
    ]
    [
        [`converter<To>`]
        [
            A _pipable_object_ type
        ]
    ]
    [
        [`converter<To>() |= x`]
        [
            `xp_make_converter<To>()(x)`
        ]
    ]
]

[h3 Preconditions]
* `x` is an _output_iterator_.
* The corresponding semantics is a valid expression.

[h3 Example]

[h3 See also]
* [link oven.applier applier]
* [link oven.converted converted]
* [link oven.transformer transformer]

[endsect]




[section copier]

[h3 Description]
`copier` outputs to another output iterator.

[h3 Header]
* `<pstade/oven/copier.hpp>`

[h3 Model of]
* _pipable_adaptor_

[h3 Notation]
* `f_` is an imaginary _function_object_ which behaves as if it were `v -> *p++ = v; *x++ = v`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`copier(p) |= x`]
        [
            `applier(f_)`
        ]
    ]
]

[h3 Preconditions]
* `x` and `p` is an _output_iterator_.
* The corresponding semantics is a valid expression.

[h3 Example]
    std::vector<int> v1, v2, v3;
    int b[] = {1,3,4,5,3,2,5,1,2};

    copy(b,
        copier(std::back_inserter(v1)) |= copier(std::back_inserter(v2))
        |= std::back_inserter(v3) );
  
[h3 See also]
* [@http://www.ddj.com/cpp/184401483 Common Knowledge: Output Iterator Adapters]
* [link oven.applier applier]
* [link oven.copied_to copied_to]

[endsect]




[section filterer]

[h3 Description]
`filterer` skips an input which doesn't satify a predicate.

[h3 Header]
* `<pstade/oven/filterer.hpp>`

[h3 Model of]
* _pipable_adaptor_

[h3 Notation]
* `f_` is an imaginary _function_object_ which behaves as if it were `v -> if(_prd(*v)) *x++ = *v`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`filterer(_prd) |= x`]
        [
            `applier(f_)`
        ]
    ]
]

[h3 Preconditions]
* `x` is an _output_iterator_.
* `_prd` is _assignable_.
* The corresponding semantics is a valid expression.

[h3 Example]

[h3 See also]
* [link oven.applier applier]
* [link oven.filtered filtered]

[endsect]




[section indirecter]

[h3 Description]
`indirecter` applies an extra dereference in outputting.

[h3 Header]
* `<pstade/oven/indirecter.hpp>`

[h3 Model of]
* _pipable_adaptor_

[h3 Notation]
* `f_` is an imaginary _function_object_ which behaves as if it were `v -> *x++ = *v`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`indirecter |= x`]
        [
            `applier(f_)`
        ]
    ]
]

[h3 Preconditions]
* `x` is an _output_iterator_.
* The corresponding semantics is a valid expression.

[h3 Example]

[h3 See also]
* [link oven.applier applier]
* [link oven.indirected indirected]
* [link oven.outdirected outdirected]

[endsect]




[section permuter]

[h3 Description]
`permuter` outputs permuted values using inputs as indices of a range.

[h3 Header]
* `<pstade/oven/permuter.hpp>`

[h3 Model of]
* _pipable_adaptor_

[h3 Notation]
* `f_` is an imaginary _function_object_ which behaves as if it were `v -> *x++ = *(_begin(_rndrng)+v)`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`permuter(_rndrng) |= x`]
        [
            `applier(f_)`
        ]
    ]
]

[h3 Preconditions]
* `x` is an _output_iterator_.
* The corresponding semantics is a valid expression.

[h3 Example]

[h3 See also]
* [link oven.applier applier]
* [link oven.permuted permuted]

[endsect]




[section transformer]

[h3 Description]
`tranformer` applies a _function_object_ to an input.

[h3 Header]
* `<pstade/oven/transformer.hpp>`

[h3 Model of]
* _pipable_adaptor_

[h3 Notation]
* `f_` is an imaginary _function_object_ which behaves as if it were `v -> *x++ = _fun(v)`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`transformer(_fun) |= x`]
        [
            `applier(f_)`
        ]
    ]
]

[h3 Preconditions]
* `x` is an _output_iterator_.
* `_fun` is _assignable_.
* The corresponding semantics is a valid expression.

[h3 Example]

[h3 See also]
* [link oven.applier applier]
* [link oven.transformed transformed]
* [link oven.range_transformer range_transformer]
* [link oven.converter converter]

[endsect]




[section range_transformer]

[h3 Description]
`range_transformer` can turn a Range Adaptor into Output Iterator Adaptor.

[h3 Header]
* `<pstade/oven/range_transformer.hpp>`

[h3 Model of]
* _pipable_adaptor_

[h3 Notation]
* `f_` is an imaginary _function_object_ which behaves as if it were `v -> x = copy(_fun(single(v)), x)`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`range_transformer(_fun) |= x`]
        [
            `applier(f_)`
        ]
    ]
]

[h3 Preconditions]
* `x` is an _output_iterator_.
* `_fun` is _assignable_.
* The corresponding semantics is a valid expression.

[h3 Example]
    file_range<boost::uint8_t> frng("utf8.txt");
    std::vector<boost::uint8_t> result;
    // Do the same job as utf8_encoder slightly inefficient way.
    copy(frng|utf8_decoded, range_transformer(make_utf8_encoded) |= std::back_inserter(result));

[h3 See also]
* [link oven.applier applier]
* [link oven.applied applied]
* [link oven.single single]
* [link oven.transformer transformer]

[endsect]




[section utf8_encoder]

[h3 Description]
Pending...

[h3 Header]
* `<pstade/oven/utf8_encoder.hpp>`

[h3 Model of]
* _pipable_adaptor_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`utf8_encoder |= x`]
        [
            `T(x)`
        ]
    ]
]

[h3 Preconditions]
* `T` is `boost::utf8_output_iterator<typeof(x)>` such that `T(x)` is a valid expression.

[h3 Example]

[h3 See also]
* [link oven.utf8_decoded utf8_decoded]

[endsect]




[section utf16_encoder]

[h3 Description]
Pending...

[h3 Header]
* `<pstade/oven/utf16_encoder.hpp>`

[h3 Model of]
* _pipable_adaptor_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`utf16_encoder |= x`]
        [
            `T(x)`
        ]
    ]
]

[h3 Preconditions]
* `T` is `boost::utf16_output_iterator<typeof(x)>` such that `T(x)` is a valid expression.

[h3 Example]

[h3 See also]
* [link oven.utf16_decoded utf16_decoded]

[endsect]




[endsect]
