[section Concepts]




[section Callable Object]

[h3 Description]
A _callable_object_ is a _function_object_ which can be used with _boost_result_of_.

[h3 Refinement of]
* _function_object_

[h3 Requirements]
In addition to the requirements defined in _function_object_,
for any _callable_object_ `f` the following must be met:

* `_typeof(f)` can be used with _boost_result_of_ to get the result type of function call `f`.

[h3 Models]
* Any function poiner
* Any _function_object_ of Oven

[endsect]


[note All the _function_object_ Oven defines are _assignable_ and _default_constructible_.]




[section Operatable Object]

[h3 Description]
An _operatable_object_ is a _callable_object_ which can specify the type of itself using prefix `op_`.

[h3 Refinement of]
* _callable_object_

[h3 Requirements]
In addition to the requirements defined in _callable_object_,
for any _operatable_object_ `f` the following must be met:

* `op_f` is `_typeof(f)`.

[h3 Models]
* [link oven.filtered make_filtered]
* [link oven.generation generation]


[endsect]




[section Pipable Object]

[h3 Description]
A _pipable_object_ supports a pipe-like syntax using `operator|` and has the associated _operatable_object_ using prefix `make_`.

[h3 Refinement of]

[h3 Requirements]
For any _pipable_object_ `p` the following must be met:

* `x|p(x0,..,xN)` is a valid expression if and only if `make_p(x, x0,..xN)` is a valid expression.
* `x|p(x0,..,xN)` and `make_p(x, x0,..xN)` have the same effects.
* `make_p` is an _operatable_object_.
* If `N` is `0`, `x|p` and `make_p(x)` are valid expressions which have the same effects.

[h3 Models]
* [link oven.filtered filtered]
* [link oven.repeat repeat]

[endsect]




[section Auxiliary Interface]

[h3 Description]
An _auxiliary_interface_ is an _operatable_object_ which supports also a pipe-like syntax
used as if it were a member function.

[h3 Refinement of]
_operatable_object_

[h3 Requirements]
In addition to the requirements defined in _operatable_object_,
for any _auxiliary_interface_ `i` the following must be met:

* `x|i(x0,..,xN)` is a valid exression if and only if `i(x, x0,..,xN)` is a valid expression.
* `x|i(x0,..xN)` and `i(x, x0,..,xN)` have the same effects.
* If `N` is `0`, `x|i()` and `x|i` are valid expressions which have the same effects.

[h3 Models]
* [link oven.as_array as_array]
* [link oven.begin_end begin]

[endsect]




[section Stoppable Generator]

[h3 Description]
A _stoppable_generator_ is a _generator_ which can specify the stop of generating using _boost_optional_.

[h3 Refinement of]
* _generator_
* _callable_object_

[h3 Requirements]
In addition to the requirements defined in _generator_ and _callable_object_,
for any _stoppable_generator_ `g` the following must be met:

* `_typeof(g())` is a `boost::optional`.
* An /uninitialized/ result is considered as the stop of generating.

[h3 Models]
* Any _callable_object_ which [link oven.nonstop nonstop] returns.

[endsect]




[section Constant Range]

[h3 Description]
A _constant_range_ is a _range_ whose iterators are constant, meaning that
the iterator referents are not modifiable.

[h3 Refinement of]
* _single_pass_range_

[h3 Requirements]
In addition to the requirements defined in _single_pass_range_,
for any _constant_range_ `r` the following must be met:

* `_iter_of<_typeof(r)>::type` is not _writable_iterator_.

[h3 Models]
* `std::list<int> const`
* `int const [12]`

[endsect]




[section Contiguous Range]

[h3 Description]
A _contiguous_range_ is a _random_access_range_ whose elements are stored contiguously.

[h3 Refinement of]
* _random_access_range_

[h3 Requirements]
In addition to the requirements defined in _random_access_range_,
for any _contiguous_range_ `r` the following must be met:

* `&*(_begin(r) + n) == &*(_begin(r)) + n` for all `n` such that `0 <= n &&  n < _end(r) - _begin(r)`.

[h3 Models]
* `std::vector<int>`
* `boost::array<char, 50>`

[endsect]




[section Lvalue Range]

[h3 Description]
A _lvalue_range_ is a _range_ whose iterator referent type is a /reference/.

[h3 Refinement of]
* _single_pass_range_

[h3 Requirements]
In addition to the requirements defined in _single_pass_range_,
for any _lvalue_range_ `r` the following must be met:

* `_iter_of<_typeof(r)>::type` is _lvalue_iterator_.

[h3 Models]
* Any `std::vector`
* Any `boost::counting_iterator`

[endsect]




[section Independent Range]

[h3 Description]
An _independent_range_ is a _range_ whose iterator referents live outside of the iterators.

[h3 Refinement of]
* _single_pass_range_

[h3 Requirements]
In addition to the requirements defined in _single_pass_range_,
for any _independent_range_ `r` the following must be met:

* If `r` is a _lvalue_range_, destruction of an iterator shall not invalidate pointers and references previously obtained from that iterator.

[h3 Models]
* Any range which is not a _lvalue_range_.
* `std::vector<int>`
* Any range which [link oven.shared shared] returns.

[h3 See also]
* C++ Standard 24.1/9

[endsect]




[endsect]
