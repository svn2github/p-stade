[section Preface]


[:["Oh Paulie!]\n[*['-- Adrian]]]




[section Introduction]

Oven is a highly preliminary implementation of _proposal_:

    namespace lambda = boost::lambda;
    using namespace pstade::oven;

    typedef
        any_range<int, boost::single_pass_traversal_tag>
    range;

    range sieve(range rng)
    {
        return rng|dropped(1)|filtered(regular(lambda::_1 % value_front(rng) != 0));
    }

    range primes
        = iteration(range(counting(2, max_count)), &::sieve)|transformed(value_front);

    int main()
    {
        std::cout << (primes|taken(200));
    }

All the types, functions and objects are defined in `namespace pstade::oven`.

[endsect]




[section Requirements]

* _boost_ Version 1.34.0 or later
* _pstade_release_ Version 1.03.1 or later (build not required)

Oven is a header-only library and usually uses header-only libraries of _boost_.
For now, `directory_range` requires _boost_filesystem_ to be built, and
 `matches` and `tokenized` requires _boost_regex_ to be built.

[endsect]




[section Portability]

Oven is known to work under the following platforms:

* Microsoft Visual C++ 2005 Express Edition SP1
* Microsoft Visual C++ .NET Version 7.1 SP1
* GCC 3.4.4

[endsect]




[section Rationale]

* Oven is functional; by using _boost_result_of_, the inferface is more simplified than using unnecessary types and templates.
* Oven is expression-oriented; as far as the expression is valid, you don't need to learn C++!?
* Oven is lightweight; never tries to do something like copying a `std::vector`.
* Oven supports an iterator such that destruction of it may invalidate pointers and references previously obtained from that iterator (24.1.9).
* Oven doesn't figure out the `distance` of non-_random_access_range_; in order to allow a very long (or complicated) range.

[endsect]




[section Related Work]

* [@http://boost-consulting.com/vault/index.php?&directory=Algorithms Boost.RangeEx]
* [@http://boost.cvs.sourceforge.net/boost-sandbox/boost-sandbox/boost/view/ Boost.View]
* [@http://sourceforge.jp/projects/cradle/ Cradle - A C++ Sandbox]
* [@http://www.ddj.com/dept/cpp/196513737 C++ View Objects]
* [@http://hamigaki.sourceforge.jp/doc/html/index.html Hamigaki C++ Libraries]
* [@http://www.torjo.com/rangelib/index.html RangeLib - The Boost Iterable Range Library]
* [@http://www.zib.de/weiser/vtl/ VTL (View Template Library)]
* [@http://www.zeta.org.au/~jon/STL/views/doc/views.html Views - a C++ Standard Library extension]

[endsect]




[section Notation]

This document uses the following notation:

[table
    [
        [[*Expression]]
        [[*Semantics]]
    ]
    [
        [`_typeof`]
        [An imaginary operator which returns the type of expression.]
    ]
    [
        [`_rng`]
        [Any _single_pass_range_, that is to say, any _range_.]
    ]
    [
        [`_fwdrng`]
        [Any _forward_range_]
    ]
    [
        [`_bidrng`]
        [Any _bidirectional_range_]
    ]
    [
        [`_rndrng`]
        [Any _random_access_range_]
    ]
    [
        [`_fun`]
        [Any _function_object_]
    ]
    [
        [`_cal`]
        [Any _callable_object_]
    ]
    [
        [`_prd`]
        [Any _predicate_]
    ]
    [
        [`_begin`]
        [`boost::begin`]
    ]
    [
        [`_end`]
        [`boost::end`]
    ]
    [
        [`_iter_of`]
        [`boost::range_result_iterator`]
    ]
    [
        [`[i, j)`]
        [A _range_ which behaves as if `i = boost::begin([i, j))` and `j = boost::end([i, j))`.]
    ]
    [
        [`{a0,a1,a2,..,aN}`]
        [A _range_]
    ]
    [
        [`(a0 a1 a2 .. aN)`]
        [A `boost::tuple`]
    ]
]

Also, assume that every expression is placed after `using namespace pstade::oven`.

[endsect]




[endsect]
