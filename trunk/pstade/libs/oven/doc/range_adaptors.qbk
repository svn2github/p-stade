[section Range Adaptors]

A Range Adaptor delivers an altered presentation of one or more underlying ranges.
Range Adaptors are lazy, meaning that their elements are only computed on demand.
The underlying ranges are not modified, and the traversal category is the same unless otherwise specified.
Additional information is available at _proposal_.




[section adjacent_filtered]

[h3 Description]
`adjacent_filtered` skips elements while a predicate applied to adjacent pairs doesn't satisfy.

[h3 Header]
* `<pstade/oven/adjacent_filtered.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Notation]
* `{a0,a1,a2,a3,..,aN}` is `_fwdrng`.
* `{b0,b1,b2,..,bM}` is a sub sequence of `{a0,a1,a2,a3,..,aN}`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_fwdrng|adjacent_filtered(_prd)`]
        [
            A _forward_ _constant_ `{b0,b1,b2,..,bM}`
        ]
    ]
]

[h3 Preconditions]
* `_prd(*_begin(_fwdrng), *_begin(_fwdrng))` is a well-formed.
* `_prd(b0, b1)`, `_prd(b1, b2)`, .., `_prd(bM-1, bM)` are `true`.
* The distance from `bI` to `bJ` is minimum for all `(bI, bJ)`.
* `_prd` is _assignable_ and _default_constructible_.

[h3 Example]

[h3 See also]
* [link oven.uniqued uniqued]

[endsect]




[section adjacent_transformed]

[h3 Description]
`adjacent_transformed` passes adjacent pairs to a function to transform repeatedly.

[h3 Header]
* `<pstade/oven/adjacent_transformed.hpp>`

[h3 Notation]
* `{a0,a1,a2,a3,..,aN}` is `_fwdrng`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`op_make_adjacent_transformed<R>`]
        [
            A _callable_object_ type
        ]
    ]
    [
        [`op_make_adjacent_transformed<R>()(_fwdrng, _fun)`]
        [
            `{_fun(a0,a1),_fun(a1,a2),_fun(a2,a3),..,_fun(aN-1,aN)}` whose `boost::range_reference` type is `R`.
        ]
    ]
    [
        [`op_make_adjacent_transformed<>()(_fwdrng, _cal)`]
        [
            `{_cal(a0,a1),_cal(a1,a2),_cal(a2,a3),..,_cal(aN-1,aN)}`
        ]
    ]
    [
        [`_fwdrng|adjacent_transformed(_cal)`]
        [
            `op_make_adjacent_transformed<>()(_fwdrng, _cal)`
        ]
    ]
]

[h3 Preconditions]
* `!boost::empty(_fwdrng)`
* `_fun(*_begin(_fwdrng), *_begin(_fwdrng))` is well-formed.
* `_fun` is _assignable_ and _default_constructible_.
* `_cal` meets the preconditions of `_fun`.

[h3 Example]

[h3 See also]
* [link oven.transformed transformed]

[endsect]




[section always]

[h3 Description]
`always` returns a range which does not change as the base range varies.

[h3 Header]
* `<pstade/oven/always.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng1|always(_rng2)`]
        [
            `[_begin(_rng2), _end(_rng2))`
        ]
    ]
]

[h3 Preconditions]

[h3 Example]
    BOOST_CHECK( equals(
        std::string("labor")
            | jointed(std::string("will be"))
            | always("lost"),
        std::string("lost")
    ) );

[endsect]




[section appended]

[h3 Description]

[h3 Header]
* `<pstade/oven/appended.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|appended(x)`]
        [
            `_rng|jointed(single(x))`
        ]
    ]
]

[h3 Preconditions]
* `_rng|jointed(single(x))` is a valid expression.

[h3 See also]
* [link oven.single single]
* [link oven.jointed jointed]
* [link oven.prepended prepended]

[endsect]




[section applied]

[h3 Description]
`applied`, given a function object which represents an algorithm, creates an adaptor.

[h3 Header]
* `<pstade/oven/applied.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|applied(_fun1, _fun2)`]
        [
            `[_fun1(_rng), _fun2(_rng))`
        ]
    ]
    [
        [`_rng|applied(_fun3)`]
        [
            `[_begin(r), _end(r))`, where `r = _fun3(_rng)`.
        ]
    ]
]

[h3 Preconditions]
* `_typeof(_fun1(_rng))` and `_typeof(_fun2(_rng))` are convertible to `_iter_of<_typeof(_rng)>::type`.
* `_iter_of<_typeof(fun3(_rng))>::type` is convertible to `_iter_of<_typeof(_rng)>::type`.
* `[_fun1(_rng), _fun2(_rng))` is a valid _range_.
* `[_begin(r), _end(_rng))`, where `r = _fun3(_rng)`, is a valid _range_.


[h3 Example]
    namespace lambda = boost::lambda;
    std::string src("abcdefghijk");
    std::string s1("efg");
    BOOST_CHECK( equals(
        std::string("efghijk"),
        src|applied(lambda::bind(search, lambda::_1, s1), end)
    ) );

[endsect]




[section broken_into]

[h3 Description]
* `broken_into` is a range adaptor version of `boost::tokenizer`.

[h3 Header]
* `<pstade/oven/broken_into.hpp>`

[h3 Model of]

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`op_make_broken_into<V>`]
        [
            A _callable_object_ type
        ]
    ]
    [
        [`op_make_broken_into<V>()(_rng, k)`]
        [
            `[T(k, _begin(_rng), _end(_rng)), T(k, _end(_rng), boost:end(_rng)))`
        ]
    ]
    [
        [`_rng|oven::broken_into<V>(k)`]
        [
            `op_make_broken_into<V>()(_rng, k)`
        ]
    ]
]

[h3 Preconditions]
* `k` is a TokenizerFunction.
* `T` is `boost::token_iterator<_typeof(k), _iter_of<_typeof(_rng)>::type, V>` such that `T(k, _begin(_rng), _end(_rng))` is a valid expression.

[h3 Example]
    int const offsets[] = { 2,2,4 };
    std::string src("12252001");
    std::vector<std::string> ans; {
        ans.push_back("12");
        ans.push_back("25");
        ans.push_back("2001");
    }

    BOOST_CHECK( equals(
        ans,
        src|oven::broken_into<std::string>(boost::offset_separator(offsets, offsets+3))
    ) );

[h3 See also]
* [@http://www.boost.org/libs/tokenizer/index.html boost::tokenizer]
* [link oven.concatenated concatenated]
* [link oven.memoized memoized]
* [link oven.tokenized tokenized]
* [link oven.xpressive_tokenized xpressive_tokenized]

[endsect]




[section checked]

[h3 Description]
`checked` adds the bounds checking ability to the base range.

[h3 Header]
* `<pstade/oven/checked.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|checked`]
        [
            `[_begin(_rng), _end(_rng))`
        ]
    ]
]

[h3 Effects]
* Throws `std::out_of_range` if iterators go out of `_rng`.

[h3 Preconditions]

[h3 Example]
    std::string in("012345");
    std::string out("01234");

    try {
        copy(in, _begin(out|checked));
    }
    catch (check_error const& ) {
        return;
    }
    BOOST_CHECK(false);

[endsect]




[section cleared]

[h3 Description]
`cleared` lets the base range viewed as empty.

[h3 Header]
* `<pstade/oven/cleared.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|cleared`]
        [
            `[_end(_rng), _end(_rng))`
        ]
    ]
]

[h3 Preconditions]

[h3 Example]
    BOOST_CHECK( boost::empty(
        std::string("labor")
            | jointed(std::string("lost"))
            | cleared
    ) );

[h3 See also]
* [link oven.empty_range empty_range]

[endsect]




[section concatenated]

[h3 Description]
`concatenated`, given a range whose `value_type` is a range, concatenates them.

[h3 Header]
* `<pstade/oven/concatenated.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Notation]
* `SegmentIterator` is `_iter_of<_typeof(_rng)>::type`.
* `LocalRange` is `boost::range_value<_typeof(_rng)>::type`.
* `LocalIterator` is `_iter_of<LocalRange>::type`.
* `{aI1,aI2,..aIMI}` is `*boost::next(_begin(_rng), I)`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|concatenated`]
        [
            An up-to-_bidirectional_ `{a11,a12,..,a1M1,a21,a22,..,a2M2,..,aN1,aN2,..,aMN}`
        ]
    ]
]

[h3 Preconditions]
* `LocalRange` is a _range_.
* Destruction of a `SegmentIterator` doesn't invalidate the `LocalIterator` previously obtained from that iterator.

[note The last precondition implies that `SegmentIterator` isn't allowed to manage the lifetime of `LocalIterator` referents.
      Hence `broken_into` and `xpressive_tokenized` can't meets the precondition.
      Fortunately, `memoized` can turn them into _lvalue_range_, which works with `concatenated`.]

[h3 Example]
    std::string input("This is his face");
    boost::regex re("\\w+");
    BOOST_CHECK( equals(
        input|tokenized(re)|concatenated,
        std::string("Thisishisface")
    ) );

[h3 See also]
* [link oven.broken_into broken_into]
* [link oven.memoized memoized]
* [link oven.tokenized tokenized]
* [link oven.xpressive_tokenized xpressive_tokenized]

[endsect]




[section constants]

[h3 Description]
`constants` converts the base range into a _constant_range_.

[h3 Header]
* `<pstade/oven/constants.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|constants`]
        [
            A _constant_ `[_begin(_rng), _end(_rng))`
        ]
    ]
]

[h3 Preconditions]

[h3 Example]

[h3 See also]

[endsect]




[section const_lvalues]

[h3 Description]
`const_lvalues` converts the base range into a _constant_range_ whose associated reference type is a /reference type/.

[h3 Header]
* `<pstade/oven/const_lvalues.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|const_lvalues`]
        [
            A _constant_ `[_begin(_rng), _end(_rng))`  whose `boost::range_reference` type is a /reference type/.
        ]
    ]
]

[h3 Preconditions]
* `boost::range_value<_typeof(_rng)>::type` is _assignable_, _copy_constructible_ and _default_constructible_.

[h3 Example]

[h3 See also]

[endsect]




[section copied_to]

[h3 Description]
`copied_to` makes a side-effect that copies the base range to an _output_iterator_.

[h3 Header]
* `<pstade/oven/copied_to.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_fwdrng|copied_to(x)`]
        [
            `[_begin(_fwdrng), _end(_fwdrng))`
        ]
    ]
]

[h3 Effects]
* `std::copy(_begin(_fwdrng), _end(_fwdrng), x)`

[h3 Preconditions]
* `std::copy(_begin(_fwdrng), _end(_fwdrng), x)` is a valid expression.

[h3 Example]

[h3 See also]

[endsect]




[section cycled]

[h3 Description]
`cycled` creates a circular range from the base range.

[h3 Header]
* `<pstade/oven/cycled.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Notation]
* `{a0,..,aN}` is `_rng`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|cycled(c)`]
        [
            `{a0,..,aN,a0,..aN,..,a0,..,aN}` where `a0,..,aN` appears `c` times.
        ]
    ]
]

[h3 Preconditions]
* `_typeof(c)` is convertible to `boost::range_difference<_typeof(_rng)>::type`.
* `0 <= c`

[h3 Example]
    BOOST_CHECK( equals(
        std::string("xyz")|cycled(3),
        std::string("xyzxyzxyz")
    ) );

[h3 See also]
* [link oven.repeat repeat]

[endsect]




[section delimited]

[h3 Description]
`delimited`, given a range of range, adds a delimiter.

[h3 Header]
* `<pstade/oven/delimited.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Notation]
* `join` is `regular(boost::lambda::bind(make_jointed, _rng2, boost::lambda::_1))`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng1|delimited(_rng2)`]
        [
            `_rng1|transformed(join)|concatenated`
        ]
    ]
]

[h3 Preconditions]
* `make_jointed(_rng2, *_begin(_rng1))` is well-formed.

[note `delimited` prepends the delimiter. `dropped` is useful to remove it.]


[h3 Example]
    BOOST_CHECK( equals(
        std::string("abcde")|transformed(single)|
            delimited("--"|as_literal)|dropped(2),
        std::string("a--b--c--d--e")
    ) );

[h3 See also]
* [link oven.dropped dropped]
* [link oven.tokenized tokenized]
* [link oven.writer writer]

[endsect]




[section dropped]

[h3 Description]
`dropped` returns the suffix of the base range after the first `n` elements.

[h3 Header]
* `<pstade/oven/dropped.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|dropped(n)`]
        [
            `[boost::next(_begin(_rng), std::min(n, distance(_rng))), _end(_rng))`
        ]
    ]
]

[h3 Preconditions]
* `_typeof(n)` is convertible to `boost::range_difference<typeof(_rng)>::type`.
* `0 <= n`

[h3 Example]
    BOOST_CHECK( equals(
        std::string("hello, dropped!")|dropped(7),
        std::string("dropped!")
    ) );

[h3 See also]
* [link oven.dropped_while dropped_while]
* [link oven.taken taken]

[endsect]




[section dropped_while]

[h3 Description]
`dropped_while` drops elements from the base range while a predicate satisfies.

[h3 Header]
* `<pstade/oven/dropped_while.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Notation]
* `not_` is an imaginary predicate to negate `_prd`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|dropped_while(_prd)`]
        [
            `[std::find_if(_begin(_rng), _end(_rng), not_(_prd)), _end(_rng))`
        ]
    ]
]

[h3 Preconditions]

[h3 Example]
    std::string src("11111234516313!");

    BOOST_CHECK( equals(
        src|dropped_while(boost::lambda::_1 == '1'),
        std::string("234516313!")
    ) );

[h3 See also]
* [link oven.dropped dropped]
* [link oven.taken_while taken_while]

[endsect]




[section filtered]

[h3 Description]
`filtered` returns a `filter_iterator` range.

[h3 Header]
* `<pstade/oven/filtered.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|filtered(_prd)`]
        [
            `[T(_prd, _begin(_rng), _end(_rng)), T(_prd, boos::end(_rng), _end(_rng)))`
        ]
    ]
]

[h3 Preconditions]
* `T` is `boost::filter_iterator<_typeof(_prd), _typeof(_begin(_rng))>` such that `T(_prd, _begin(_rng), _end(_rng))` is a valid expression.
* `_prd` is _assignable_.
* If `_rng` is a _forward_range_, `_prd` is _default_constructible_.

[h3 Example]

[h3 See also]
* [@http://www.boost.org/libs/iterator/doc/filter_iterator.html boost::filter_iterator]
* [link oven.dropped_while dropped_while]

[endsect]




[section firsts]

[h3 Description]

[h3 Header]
* `<pstade/oven/firsts.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Notation]
* `first_of` is an imaginary function which returns a member `first`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|firsts`]
        [
            `_rng|transformed(first_of)`
        ]
    ]
]

[h3 Preconditions]
* `range_value<_typeof(_rng)>::type` is a `std::pair`.
* `_rng|transformed(first_of)` is a valid expression.

[h3 Example]

[h3 See also]
* [link oven.seconds seconds]

[endsect]




[section identities]

[h3 Description]
`identities` returns the base range as is, but can change the traversal category.

[h3 Header]
* `<pstade/oven/identities.hpp>`

[h3 Model of]

[h3 Notation]
* `traversal` is an imaginary metafunction which returns a traversal tag type known as `boost::xxx_traversal_tag`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`op_make_identities<>`]
        [
            A _callable_object_ type
        ]
    ]
    [
        [`op_make_identities<>()(_rng)`]
        [
            `[_begin(_rng), _end(_rng))`
        ]
    ]
    [
        [`op_make_identities<>()(_rng, t)`]
        [
            `[_begin(_rng), _end(_rng))` whose `traversal` type is `_typeof(t)`.
        ]
    ]
    [
        [`_rng|identities`]
        [
            `op_make_identities<>()(_rng)`
        ]
    ]
    [
        [`_rng|identities(t)`]
        [
            `op_make_identities<>()(_rng, t)`
        ]
    ]
]

[h3 Preconditions]
* There is a `xxx` such that `_typeof(t)` is `boost::xxx_traversal_tag`.
* `traversal<_typeof(_rng)>::type` is convertible to `_typeof(t)`.

[h3 Example]

[h3 See also]

[endsect]




[section indirected]

[h3 Description]
`indirected` adapts the base range by applying an extra dereference inside of `operator*()`.

[h3 Header]
* `<pstade/oven/indirected.hpp>`

[h3 Model of]

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`op_make_indirected<A0,..,AN>`]
        [
            A _callable_object_ type
        ]
    ]
    [
        [`op_make_indirected<A0,..,AN>()(_rng)`]
        [
            `[T(_begin(_rng), T(_end(_rng)))`
        ]
    ]
    [
        [`make_indirected(_rng)`]
        [
            `op_make_indirected<>()(_rng)`
        ]
    ]
    [
        [`_rng|indirected`]
        [
            `make_indirected(_rng)`
        ]
    ]
]

[h3 Preconditions]
* `T` is `boost::indirect_iterator<_iter_of<_typeof(_rng)>::type, A0,..,AN>` such that `T(_begin(_rng))` is a valid expression.

[h3 Example]
    int src[]    = { 1,2,0,4,5 };
    int answer[] = { 1,2,3,4,5 };
    int *ptrs[]  = {&src[0],&src[1],&src[2],&src[3],&src[4]};

    BOOST_FOREACH (int& i, ptrs|indirected) {
        if (i == 0)
            i = 3;
    }

    BOOST_CHECK( equals(src, answer) );

[h3 See also]
* [@http://www.boost.org/libs/iterator/doc/indirect_iterator.html boost::indirect_iterator]
* [link oven.outdirected outdirected]

[endsect]




[section jointed]

[h3 Description]
`jointed` returns a range which is jointed with its argument.

[h3 Header]
* `<pstade/oven/jointed.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Notation]
* `{a0,..,aN}` is `_rng1`.
* `{b1,..,bM}` is `_rng2`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng1|jointed(_rng2)`]
        [
            `{a0,..aN,b0,..bM}`
        ]
    ]
]

[h3 Preconditions]
* `boost::range_reference<_typeof(_rng2)>::type` is convertible to `boost::range_reference<_typeof(_rng1)>::type`
  without binding /reference/ to /rvalue/.

[h3 Example]
    std::string str0("every range");
    std::vector<char> str1 = std::string(" is")|copied;
    std::list<char> str2 = std::string(" string!?")|copied;

    BOOST_CHECK( equals(
        str0|jointed(str1)|jointed(str2),
        std::string("every range is string!?")
    ) );

[h3 See also]
* [link oven.appended appended]
* [link oven.prepended prepended]

[endsect]




[section map_keys]

[h3 Description]
`map_keys` returns a range whose values are the keys of the base associative container.

[h3 Header]
* `<pstade/oven/map_keys.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng1|map_keys`]
        [
            `_rng|firsts`
        ]
    ]
]

[h3 Preconditions]
* `_rng|firsts` is a valid expression.

[h3 Example]
    std::map<int, std::string> m;
    m[12] = "hello";
    m[4]  = "map";
    m[99] = "keys";

    BOOST_FOREACH (int k, m|map_keys) {
        BOOST_CHECK( k != 12 || m[k] == "hello" );
        BOOST_CHECK( k != 4  || m[k] == "map" );
        BOOST_CHECK( k != 99 || m[k] == "keys" );
    }

[h3 See also]
* [link oven.firsts firsts]
* [link oven.map_keys map_keys]

[endsect]




[section map_values]

[h3 Description]
`map_values` returns a range whose values are the mapped values of the base associative container.

[h3 Header]
* `<pstade/oven/map_values.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng1|map_values`]
        [
            `_rng|seconds`
        ]
    ]
]

[h3 Preconditions]
* `_rng|seconds` is a valid expression.

[h3 Example]
    std::map<int, std::string> m;
    m[12] = "hello";
    m[4]  = "map";
    m[99] = "keys";

    BOOST_FOREACH (std::string& v, m|map_values) {
        if (v == "keys")
            v = "values";
    }

    BOOST_CHECK( m[12] == "hello" );
    BOOST_CHECK( m[4]  == "map" );
    BOOST_CHECK( m[99] == "values" );

[h3 See also]
* [link oven.map_keys map_keys]
* [link oven.seconds seconds]

[endsect]




[section matches]

[h3 Description]
`matches` returns a `boost::regex_iterator` range.

[h3 Header]
* `<pstade/oven/matches.hpp>`

[h3 Model of]

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`op_make_matches<X0,..,XN>`]
        [
            A _callable_object_ type
        ]
    ]
    [
        [`op_make_matches<X0,..,XN>()(_bidrng, y0,..,yM)`]
        [
            `[T(_begin(_rng), _end(_rng), y0,..,yM), T())`
        ]
    ]
    [
        [`_bidrng|matches(y0,..,yM)`]
        [
            `op_make_tokenized<>()(_bidrng, y0,..,yM)`
        ]
    ]
]

[h3 Preconditions]
* `T` is `boost::regex_iterator<_iter_of<_typeof(_rng)>::type, X0,..,XN>` such that `T(_begin(_rng), _end(_rng), y0,..,yM)` is a valid expression.

[h3 Example]

[h3 See also]
* [@http://www.boost.org/libs/regex/doc/regex_iterator.html boost::regex_iterator]
* [link oven.tokenized tokenized]

[endsect]




[section memoized]

[h3 Description]
`memoized` returns a range whose values are cached for speed, preparing for repeated dereferences.

[h3 Header]
* `<pstade/oven/memoized.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|memoized`]
        [
            A _forward_ _constant_ _lvalue_ `[_begin(_rng), _end(_rng))`
        ]
    ]
    [
        [`_rng|memoized(t)`]
        [
            `_rng|memoized`
        ]
    ]
]

[note `memoized` can return a _forward_range_ even if the base range is a _single_pass_range_.]

[h3 Preconditions]
* `boost::range_value<_typeof(_rng)>::type` is _assignable_ and _copy_constructible_.
* If `_rng` is a recursive range, `memo_table` object `t` must be passed.

[h3 Example]
    std::stringstream ss;
    ss << "hello, memoized!";

    ::very_complicated_algorithm(
        oven::reading<char>(ss)
            | memoized
            | directed
            | indirected
            | sorted
            | memoized
    );

[h3 See also]
* [link oven.any_range any_range]
* [link oven.recursion recursion]

[endsect]




[section merged]

[h3 Description]
`merged` combines two sorted ranges into a single sorted range.

[h3 Header]
* `<pstade/oven/merged.hpp>`

[h3 Model of]

[h3 Notation]
* `less` is `regular(boost::lambda::_1 < boost::lambda::_2)`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`op_make_merged<>`]
        [
            A _callable_object_ type
        ]
    ]
    [
        [`op_make_merged<>()(_rng1, _rng2, _prd)`]
        [
            An up-to-_forward_ _constant_range_ which behaves as if it were made by `merge(_rng1, _rng2, _prd)`.
        ]
    ]
    [
        [`op_make_merged<>()(_rng1, _rng2)`]
        [
            `op_make_merded<>()(_rng1, _rng2, less))`
        ]
    ]
    [
        [`_rng1|merged(_rng2, _prd)`]
        [
            `op_make_merged<>()(_rng1, _rng2, _prd)`
        ]
    ]
    [
        [`_rng1|merged(_rng2)`]
        [
            `op_make_merged<>()(_rng1, _rng2)`
        ]
    ]
]

[h3 Preconditions]
* `boost::range_reference<_typeof(_rng2)>::type` is convertible to `boost::range_reference<_typeof(_rng1)>::type`
  without binding /reference/ to /rvalue/.
* `_rng1` and `_rng2` are sorted.
* `_prd` is _assignable_.
* If `_rng1` and `_rng2` are _forward_range_s, `_prd` is _default_constructible_.

[h3 Example]
    std::string A1("abbbfH");
    std::string A2("ABbCDFFhh");
    std::string AA("aAbbbBbCDfFFHhh");
    BOOST_CHECK( equals(A1|merged(A2, &::lt_nocase), AA) );

[h3 See also]
* [link oven.set_cap set_cap]
* [link oven.set_cup set_cup]
* [link oven.set_delta set_delta]
* [link oven.set_minus set_minus]

[endsect]




[section offset]

[h3 Description]

[h3 Header]
* `<pstade/oven/offset.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_fwdrng|offset(n, m)`]
        [
            `[boost::next(_begin(_fwdrng), n), boost::next(_end(_fwdrng), m))`
        ]
    ]
]

[h3 Preconditions]
* `boost::next(_begin(_fwdrng), n)` is a valid expression.
* `boost::next(_end(_fwdrng), m)` is a valid expression.

[h3 Example]

[h3 See also]
* [link oven.sliced sliced]
* [link oven.window window]

[endsect]




[section outdirected]

[h3 Description]
`outdirected` returns a range whose values are iterators of the base range.

[h3 Header]
* `<pstade/oven/outdirected.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|outdirected`]
        [
            `counting(_begin(_rng), _end(_rng))`
        ]
    ]
]

[h3 Preconditions]

[h3 Example]
    std::string const str("gefadcb");
    std::string const answer("abcdefg");

    std::vector<std::string::const_iterator> iters;
    copy(str|outdirected, std::back_inserter(iters));
    sort( iters, boost::make_indirect_fun(::less_than()) );

    BOOST_CHECK( equals(iters|indirected, answer) );

[h3 See also]
* [link oven.indirected indirected]
* [link oven.pointed pointed]

[endsect]




[section permuted]

[h3 Description]
`permuted` provides a permuted view of a given range.
That is, the view includes every element of the given range but in a potentially different order.

[h3 Header]
* `<pstade/oven/permuted.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng1|permuted(_rng2)`]
        [
            `[T(_begin(_rng1), _begin(_rng2)), T(_begin(_rng1), _end(_rng2))))`
        ]
    ]
]

[h3 Preconditions]
* `T` is `boost::permutation_iterator<_iter_of<_typeof(_rng1)>::type, _iter_of<_typeof(_rng2)>::type>` such that `T(_begin(_rng1), _begin(_rng2))` is a valid expression.

[h3 Example]

[h3 See also]
* [@http://www.boost.org/libs/iterator/doc/permutation_iterator.html boost::permutation_iterator]
* [link oven.sliced sliced]

[endsect]




[section pointed]

[h3 Description]
`pointed`, by returning a pointer range, provides an interface to have a conversation with legacy APIs.

[h3 Header]
* `<pstade/oven/pointed.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`r|pointed`]
        [
            `[p, p + distance(r))`, where `p = &*_begin(r)`.
        ]
    ]
    [
        [`q|pointed`]
        [
            `[(P)0, (P)0)`, where `P` is `boost::range_pointer<_typeof(q)>::type`.
        ]
    ]
]

[h3 Preconditions]
* `r` is a _contiguous_range_ such that `!boost::empty(r)`.
* `q` is a _contiguous_range_ such that `boost::empty(q)`.

[h3 Example]
    std::string const src("hello, pointed");
    std::vector<char> vec;
    vec.resize(oven::distance(src) + 1);
    std::strcpy(boost::begin(vec|pointed), src.c_str());
    BOOST_CHECK(( equals(vec|as_c_str, src) ));

[h3 See also]
* [link oven.outdirected outdirected]

[endsect]




[section popped]

[h3 Description]
`popped` returns a range without the last element.

[h3 Header]
* `<pstade/oven/popped.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_fwdrng|popped`]
        [
            `[_begin(_fwdrng), boost::next(_begin(_fwdrng), distance(_fwdrng) - 1))`
        ]
    ]
]

[h3 Preconditions]
* `!boost::empty(_fwdrng)`

[h3 Example]

[h3 See also]
* [link oven.dropped dropped]

[endsect]




[section prepended]

[h3 Description]

[h3 Header]
* `<pstade/oven/prepended.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|prepended`]
        [
            `single(v)|jointed(_rng)`
        ]
    ]
]

[h3 Preconditions]
* `single(v)|jointed(_rng)` is a valid expression.

[h3 Example]

[h3 See also]
* [link oven.appended appended]
* [link oven.single single]
* [link oven.jointed jointed]

[endsect]




[section reversed]

[h3 Description]
A range returned from `reversed` iterates in the opposite direction.

[h3 Header]
* `<pstade/oven/reversed.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_bidrng|reversed`]
        [
            `[T(boost:end(_bidrng)), T(_begin(_bidrng)))`
        ]
    ]
]

[h3 Preconditions]
* `T` is `boost::reverse_iterator<boost::_iter_of<_typeof(_bidrng)>::type>` such that `T(_begin(_bidrng))` is a valid expression.

[h3 Example]

[h3 See also]
* [@http://www.boost.org/libs/iterator/doc/reverse_iterator.html boost::reverse_iterator]

[endsect]




[section scanned]

[h3 Description]
`scanned` is similar to `std::accumulate`, but returns a range of successive reduced values from the base range.

[h3 Header]
* `<pstade/oven/scanned.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Notation]
* `{a0,a1,a2,..,aN}` is `_rng`.
* `{b1,b2,b3,..,bM}` is `_rng1`.
* `S1` is `range_value<_typeof(_rng1)>::type`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|scanned(s, _fun)`]
        [
            An up-to-_forward_ `{s,_fun(s, a0),_fun(_fun(s, a0), a1),_fun(_fun(_fun(s, a0), a1), a2),..,aN)}`
        ]
    ]
    [
        [`_rng1|scanned(_fun1)`]
        [
            An up-to-_forward_ `{b1,_fun1(b1, b2),_fun1(_fun(b1, b2), b3),_fun1(_fun1(_fun1(b1, b2), b3), b4),..,bM)}`
        ]
    ]
]

[h3 Preconditions]
* `_typeof(s)` is _assignable_ and _copy_constructible_.
* `_fun(_fun(s, a), a)` is well-formed, where `a = *_begin(_rng))`.
* `S1` is _assignable_ and _copy_constructible_.
* `_fun1(_fun1(b, b), b)` is well-formed, where `b = *_begin(_rng))`.
* `!boost::empty(_rng1)`
* `_fun` and `_fun1` are _assignable_.
* If `_rng` is a _forward_range_, `_fun` and `_typeof(s)` are _default_constructible_.
* If `_rng1` is a _forward_range_, `_fun1` ard `S1` are _default_constructible_.

[h3 Example]
    int const src[] = { 1,2,3,4,5 };
    std::string null;

    BOOST_FOREACH (std::string str, src|scanned(null, &::stringize)) {
        std::cout << "\"" << str << "\" ";
    }
    // outputs: "" "1" "12" "123" "1234" "12345"

[h3 See also]
* [@http://www.zvon.org/other/haskell/Outputprelude/scanl_f.html scanl]
* [@http://www.zvon.org/other/haskell/Outputprelude/scanl1_f.html scanl1]

[endsect]




[section seconds]

[h3 Description]

[h3 Header]
* `<pstade/oven/seconds.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Notation]
* `second_of` is an imaginary function which returns a member `second`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|seconds`]
        [
            `_rng|transformed(second_of)`
        ]
    ]
]

[h3 Preconditions]
* `range_value<_typeof(_rng)>::type` is a `std::pair`.
* `_rng|transformed(second_of)` is a valid expression.

[h3 Example]

[h3 See also]
* [link oven.firsts firsts]

[endsect]




[section set_cap]

[h3 Description]

[h3 Header]
* `<pstade/oven/set_cap.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng1|set_cap(_rng2, _prd)`]
        [
            An up-to-_forward_ _constant_range_ which behaves as if it were made by `set_intersection(_rng1, _rng2, _prd)`.
        ]
    ]
    [
        [`_rng1|set_cap(_rng2)`]
        [
            `_rng1|set_cap(_rng2, less)`
        ]
    ]
]

[h3 Preconditions]
* The preconditions of `merged`.

[h3 Example]

[h3 See also]
* [link oven.merged merged]
* [link oven.set_cup set_cup]
* [link oven.set_delta set_delta]
* [link oven.set_minus set_minus]

[endsect]




[section set_cup]

[h3 Description]

[h3 Header]
* `<pstade/oven/set_cup.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng1|set_cup(_rng2, _prd)`]
        [
            An up-to-_forward_ _constant_range_ which behaves as if it were made by `set_union(_rng1, _rng2, _prd)`.
        ]
    ]
    [
        [`_rng1|set_cup(_rng2)`]
        [
            `_rng1|set_cup(_rng2, less)`
        ]
    ]
]

[h3 Preconditions]
* The preconditions of `merged`.

[h3 Example]

[h3 See also]
* [link oven.merged merged]
* [link oven.set_cap set_cap]
* [link oven.set_delta set_delta]
* [link oven.set_minus set_minus]

[endsect]




[section set_delta]

[h3 Description]

[h3 Header]
* `<pstade/oven/set_delta.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng1|set_delta(_rng2, _prd)`]
        [
            An up-to-_forward_ _constant_range_ which behaves as if it were made by `set_symmetric_difference(_rng1, _rng2, _prd)`.
        ]
    ]
    [
        [`_rng1|set_delta(_rng2)`]
        [
            `_rng1|set_delta(_rng2, less)`
        ]
    ]
]

[h3 Preconditions]
* The preconditions of `merged`.

[h3 Example]

[h3 See also]
* [link oven.merged merged]
* [link oven.set_cap set_cap]
* [link oven.set_cup set_cup]
* [link oven.set_minus set_minus]

[endsect]




[section set_minus]

[h3 Description]

[h3 Header]
* `<pstade/oven/set_minus.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng1|set_minus(_rng2, _prd)`]
        [
            An up-to-_forward_ _constant_range_ which behaves as if it were made by `set_difference(_rng1, _rng2, _prd)`.
        ]
    ]
    [
        [`_rng1|set_minus(_rng2)`]
        [
            `_rng1|set_minus(_rng2, less)`
        ]
    ]
]

[h3 Preconditions]
* The preconditions of `merged`.

[h3 Example]

[h3 See also]
* [link oven.merged merged]
* [link oven.set_cap set_cap]
* [link oven.set_cup set_cup]
* [link oven.set_delta set_delta]

[endsect]




[section sliced]

[h3 Description]
`sliced` provides a column view of the base range.

[note This name comes from `std::slice` and different from _proposal_, which is the role of `offset` or `window`.]

[h3 Header]
* `<pstade/oven/sliced.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Notation]
* `f` is `_begin(_rndrng)`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rndrng|sliced(s, t)`]
        [
            `{*(f+s+t*0),*(f+s+t*1),*(f+s+t*2),..,*(f+s+t*(n-1))}`
        ]
    ]
]

[h3 Preconditions]
* `_typeof(s)` and `_typeof(t)` are convertible to `boost::range_difference<typeof(_rndrng)>::type`.
* `n` is `distance(_rndrng) / t` such that `n == 0 || n % t == 0`.
* `0 <= s && s < t`

[h3 Example]
    int const answer[] = { 2,6,10,14 };
    BOOST_CHECK( equals(answer,
        counting(0, 16)|sliced(2, 4)
    ) );

[h3 See also]
* [link oven.offset offset]
* [link oven.steps steps]
* [link oven.window window]

[endsect]




[section steps]

[h3 Description]
`steps`, though it can't return _bidirectional_range_, relaxes the preconditions of `sliced` and accepts a _single_pass_range_.

[h3 Header]
* `<pstade/oven/steps.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Notation]
* `iK = boost::next(boost::begin(_rng), w*K))`

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|steps(w)`]
        [
            An up-to-_forward_ `{*i0,*i1,*i2,*i3,..,*iM}`
        ]
    ]
]

[h3 Preconditions]
* `_typeof(w)` is convertible to `boost::range_difference<_typeof(_rng)>::type`.
* `1 <= w`
* `M` is the largest number such that `iM < _end(_rng)`.

[h3 Example]
    int const answer[] = { 0, 40, 80 };
    BOOST_CHECK( equals(
        counting(0, 100)|steps(10)|steps(4),
        answer
    ) );

[h3 See also]
* [link oven.sliced sliced]

[endsect]




[section string_found]

[h3 Description]
`string_found` returns a `boost::find_iterator` range.

[h3 Header]
* `<pstade/oven/string_found.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|string_found`]
        [
            `[T(_rng, f), T())`
        ]
    ]
]

[h3 Preconditions]
* `f` is a Finder.
* `T` is `boost::find_iterator<_iter_of<_typeof(_rng)>::type>` such that `T(_rng, f)` is a valid expression.

[h3 Example]

[h3 See also]
* [@http://www.boost.org/doc/html/find_iterator.html boost::find_iterator]

[endsect]



[section string_split]

[h3 Description]
`string_split` returns a `boost::split_iterator` range.

[h3 Header]
* `<pstade/oven/string_split.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|string_split`]
        [
            `[T(_rng, f), T())`
        ]
    ]
]

[h3 Preconditions]
* `f` is a Finder.
* `T` is `boost::split_iterator<_iter_of<_typeof(_rng)>::type>` such that `T(_rng, f)` is a valid expression.

[h3 Example]

[h3 See also]
* [@http://www.boost.org/doc/html/split_iterator.html boost::split_iterator]

[endsect]




[section taken]

[h3 Description]
`taken`, applied to the base range, returns the prefix of the range of length `n`.

[h3 Header]
* `<pstade/oven/taken.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|taken(n)`]
        [
            An up-to-_forward_ `[_begin(_rng), boost::next(_begin(_rng), std::min(n, distance(_rng))))`
        ]
    ]
]

[h3 Preconditions]
* `_typeof(n)` is convertible to `range_difference<_typeof(_rng)>::type`.

[h3 Example]

[h3 See also]
* [link oven.dropped dropped]
* [link oven.taken_while taken_while]

[endsect]




[section taken_while]

[h3 Description]
`taken_while`, applied to a predicate and the base range,
returns the longest prefix (possibly empty) of the range of elements that satisfy the predicate.

[h3 Header]
* `<pstade/oven/taken_while.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Notation]
* `not_` is an imaginary predicate to negate `_prd`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_rng|taken_while(_prd)`]
        [
            An up-to-_forward_ `[_begin(_rng), std::find_if(_begin(_rng), _end(_rng), not_(_prd)))`
        ]
    ]
]

[h3 Preconditions]
* `_typeof(n)` is convertible to `range_difference<_typeof(_rng)>::type`.
* `_prd` is _assignable_.
* If `_rng` is a _forward_range_, `_prd` is _default_constructible_.

[h3 Example]

[h3 See also]
* [link oven.dropped_while dropped_while]
* [link oven.taken taken]

[endsect]




[section tokenized]

[h3 Description]
`tokenized` returns a `boost::regex_token_iterator` range.

[h3 Header]
* `<pstade/oven/tokenized.hpp>`

[h3 Model of]

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`op_make_tokenized<Y1,..,YN>`]
        [
            A _callable_object_ type
        ]
    ]
    [
        [`op_make_tokenized<Y1,..,YN>()(_bidrng, x1,..,xM)`]
        [
            `[T(_begin(_rng), _end(_rng), x1,..,xM), T())`
        ]
    ]
    [
        [`_bidrng|tokenized(x1,..,xM)`]
        [
            `op_make_tokenized<>()(_bidrng, x1,..,xM)`
        ]
    ]
]

[h3 Preconditions]
* `T` is `boost::regex_token_iterator<_iter_of<_typeof(_rng)>::type, Y1,..,YN>` such that `T(_begin(_rng), _end(_rng), x1,..,xM)` is a valid expression.

[h3 Example]

[h3 See also]
* [@http://www.boost.org/libs/regex/doc/regex_token_iterator.html boost::regex_token_iterator]
* [link oven.broken_into broken_into]

[endsect]




[section transformed]

[h3 Description]
`transformed` returns a `transform_iterator` range.

[h3 Header]
* `<pstade/oven/transformed.hpp>`

[h3 Model of]

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`op_make_transformed<R>`]
        [
           A _callable_object_ type
        ]
    ]
    [
        [`op_make_transformed<R>()(_rng, _fun)`]
        [
            `[T(_begin(_rng), _fun), T(_end(_rng), _fun))`, whose `boost::range_reference` type is `R`.
        ]
    ]
    [
        [`op_make_transformed<>`]
        [
           A _callable_object_ type
        ]
    ]
    [
        [`op_make_transformed<>()(_rng, _cal)`]
        [
            `[U(_begin(_rng), _cal), U(_end(_rng), _cal))`
        ]
    ]
    [
        [`make_transformed(_rng, _cal)`]
        [
            `op_make_transformed<>()(_rng, _cal)`
        ]
    ]
    [
        [`_rng|transformed(_cal)`]
        [
            `make_transformed(_rng, _cal)`
        ]
    ]
]

[h3 Preconditions]
* `T` is `boost::transform_iterator<_typeof(_fun), _typeof(_begin(_rng)), R>` such that `T(_begin(_rng), _fun)` is a valid expression.
* `U` is `boost::transform_iterator<_typeof(_cal), _typeof(_begin(_rng)), boost::result_of<_typeof(_cal)(*_begin(_rng))>::type>` such that `U(_begin(_rng), _cal)` is a valid expression.
* `_fun` and `_cal` are _assignable_.
* If `_rng` is a _forward_range_, `_fun` and `_cal` are _default_constructible_.

[h3 Example]

[h3 See also]
* [@http://www.boost.org/libs/iterator/doc/transform_iterator.html boost::transform_iterator]

[endsect]




[section uniqued]

[h3 Description]

[h3 Header]
* `<pstade/oven/uniqued.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Notation]
* `not_eq_` is `regular(boost::lambda::_1 != boost::lambda::_2)`.

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_fwdrng|uniqued`]
        [
            `_fwdrng|adjacent_filtered(not_eq_)`
        ]
    ]
]

[h3 Preconditions]
* `_fwdrng|adjacent_filtered(not_eq_)` is a valid expression.

[h3 Example]

[h3 See also]
* [link oven.adjacent_filtered adjacent_filtered]

[endsect]




[section window]

[h3 Description]

[h3 Header]
* `<pstade/oven/window.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_fwdrng|window(n, m)`]
        [
            `[boost::next(_begin(_fwdrng), n), boost::next(_begin(_fwdrng), m))`
        ]
    ]
]

[h3 Preconditions]
* `boost::next(_begin(_fwdrng), n)` is a valid expression.
* `boost::next(_begin(_fwdrng), m)` is a valid expression.

[h3 Example]

[h3 See also]
* [link oven.sliced sliced]
* [link oven.offset offset]

[endsect]




[section xpressive_matches]

[h3 Description]
`xpressive_matches` returns a `boost::xpressive::regex_iterator` range.

[h3 Header]
* `<pstade/oven/xpressive_matches.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_bidrng|xpressive_matches(x0,..,xN)`]
        [
            `[T(_begin(_bidrng), _end(_bidrng), x0,..,xN), T())`
        ]
    ]
]

[h3 Preconditions]
* `T` is `boost::xpressive::regex_iterator<boost::range_const_iterator<_typeof(_bidrng)>::type>` such that `T(_begin(_bidrng), _end(_bidrng), x0,..,xN)` is a valid expression.

[h3 Example]

[h3 See also]
* [@http://boost-sandbox.sourceforge.net/libs/xpressive/doc/html/header/boost/xpressive/regex_iterator/hpp.html boost::xpressive::regex_iterator]
* [link oven.matches matches]
* [link oven.xpressive_tokenized xpressive_tokenized]

[endsect]




[section xpressive_tokenized]

[h3 Description]
`xpressive_tokenized` returns a `boost::xpressive::regex_token_iterator` range.

[h3 Header]
* `<pstade/oven/xpressive_tokenized.hpp>`

[h3 Model of]
* _pipable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_bidrng|xpressive_tokenized(x0,..,xN)`]
        [
            `[T(_begin(_bidrng), _end(_bidrng), x0,..,xN), T())`
        ]
    ]
]

[h3 Preconditions]
* `T` is `boost::xpressive::regex_token_iterator<boost::range_const_iterator<_typeof(_bidrng)>::type>` such that `T(_begin(_bidrng), _end(_bidrng), x0,..,xN)` is a valid expression.

[h3 Example]

[h3 See also]
* [@http://boost-sandbox.sourceforge.net/libs/xpressive/doc/html/header/boost/xpressive/regex_token_iterator/hpp.html boost::xpressive::regex_token_iterator]
* [link oven.concatenated concatenated]
* [link oven.memoized memoized]
* [link oven.tokenized tokenized]
* [link oven.xpressive_matches xpressive_matches]

[endsect]




[endsect]
