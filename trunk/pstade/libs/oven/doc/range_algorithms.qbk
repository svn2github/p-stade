[section Range Algorithms]

Oven provides range-based algorithms using a _range_ instead of two iterators.




[section STL Algorithms]

[h3 Description]
`algorithm.hpp` is considered as range-based `<algorithm>`.

[h3 Header]
* `<pstade/oven/algorithm.hpp>`

[h3 Model of]
* _operatable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`algo1(_rng, x1,..,xN)`]
        [`std::algo1(_begin(_rng), _end(_rng), x1,..,xN)`]
    ]
    [
        [`algo2(_rng1, _rng2, x1,..,xN)`]
        [`std::algo2(_begin(_rng1), _end(_rng1), _begin(_rng2), _end(_rng2), x1,..,xN)`]
    ]
    [
        [`algoM(_rng, _fun, x1,..,xN)`]
        [`std::algoM(_begin(_rng), _fun(_rng), _end(_rng), x1,..,xN)`]
    ]
]

[h3 Preconditions]
* `algo1` and `algo2` is one of the function names defined in `<algorithm>` except for...
    * `fill_n`, `generate_n`, `rotate`, `rotate_copy`, `partial_sort`, `nth_element` and `inplace_merge`.
* `std::algo1(_begin(_rng), _end(_rng), x1,..,xN)` is a valid exression.
* `std::algo2(_begin(_rng1), _end(_rng1), _begin(_rng2), _end(_rng2), x1,..,xN)` is a valid expression.
* `algoM` is one of the following names...
    * `rotate`, `rotate_copy`, `partial_sort`, `nth_element` and `inplace_merge`.
* `std::algoM(_begin(_rng), m, _end(_rng), x1,..,xN)` is a valid expression.
* `_fun(_rng)` is a valid expression.
* `_typeof(_fun(_rng))` is `_iter_of<_typeof(_rng)>::type`.

[note `fill_n` and `generate_n` are not considered as range algorithm, so they are excluded.]

[h3 Example]
    std::string str;

    // iterator-based
    str = "gfedcba";
    std::sort(str.begin(), str.end());
    BOOST_CHECK( str == "abcdefg" );

    // Oven range-based
    str = "gfedcba";
    sort(str);
    BOOST_CHECK( str == "abcdefg" );

[endsect]




[section STL Numerics]

[h3 Description]
`numeric.hpp` is considered as range-based `<numeric>`.

[h3 Header]
* `<pstade/oven/numeric.hpp>`

[h3 Model of]
* _operatable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`algo(_rng, x1,..,xN)`]
        [`std::algo(_begin(_rng), _end(_rng), x1,..,xN)`]
    ]
]

[h3 Preconditions]
* `algo` is one of the function names defined in `<numeric>`.
* `std::algo(_begin(_rng), _end(_rng), x1,..,xN)` is a valid expression.

[endsect]


[note Unfortunately, Oven STL Algorithms and Numerics are not traversal-aware.
A _random_access_range_ whose iterator is not _lvalue_iterator_ is regarded as an _input_iterator_ range.]




[section at]

[h3 Header]
* `<pstade/oven/at.hpp>`

[h3 Model of]
* _auxiliary_interface_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`at(_rndrng, n)`]
        [`*(_begin(_rndrng) + n)`]
    ]
]

[h3 Preconditions]
* `_typeof(n)` is convertible to `boost::range_difference<_typeof(_rndrng)>::type`.
* `0 <= n && n < distance(_rndrng)`
* Destruction of an iterator doesn't invalidate references previously obtained from that iterator.

[note you must use [link oven.value_at value_at] if an iterator invalidates references after the destruction.]

[h3 Example]
    std::string str("f12344513215b");
    BOOST_CHECK( at(str, 0) == 'f' );
    BOOST_CHECK( (str|at(4)) == '4' );

[h3 See also]
* [link oven.value_at value_at]

[endsect]




[section begin/end]

[h3 Description]
`begin` and `end` is the _auxiliary_interface_ version of `_begin` and `_end` respectively.

[h3 Header]
* `<pstade/oven/begin_end.hpp>`

[h3 Model of]
* _auxiliary_interface_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`begin(_rng)`]
        [`_begin(_rng)`]
    ]
    [
        [`end(_rng)`]
        [`_end(_rng)`]
    ]
]

[h3 Example]
    std::string src("abcDefg");   
    oven::copy(src|reversed|transformed(to_upper), src|reversed|begin);
    BOOST_CHECK( oven::equals(src, std::string("ABCDEFG")) );
    
[endsect]




[section copied]

[h3 Description]
`copied` automagically calls `boost::copy_range` without specifying the return type.

[h3 Header]
* `<pstade/oven/copy_range.hpp>`

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`Rng1 _rng1 = _rng2|copied;`]
        [`Rng1 _rng1 = boost::copy_range<Rng1>(_rng2);`]
    ]
]

[h3 Preconditions]
* `Rng1 _rng1 = boost::copy_range<Rng1>(_rng2);` is a valid expression.
* `copied` isn't placed in a function default argument list.

[note The valid expression implies you can place `copied` everywhere it is used in /copy-initialization/, e.g. `return` statement.
The second precondition comes from a GCC bug. Notice that `Rng1 _rng1(_rng2|copied);` is not listed in valid expressions.]

[h3 Example]
    std::string _rng("abcdefg");
    std::vector<char> vec = _rng|copied;
    BOOST_CHECK( equals(vec, _rng) );

[endsect]




[section distance]

[h3 Description]
`distance` is a range-based `std::distance` but traversal-aware.

[h3 Header]
* `<pstade/oven/distance.hpp>`

[h3 Model of]
* _auxiliary_interface_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`distance(_rng)`]
        [`std::distance(_begin(_rng), _end(_rng))`]
    ]
]

[endsect]




[section equals]

[h3 Description]
`equals` is a range-based `std::equal` but sensitive to the distances.

[h3 Header]
* `<pstade/oven/equals.hpp>`

[h3 Model of]
* _callable_object_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`equals(_rng1, _rng2, _prd)`]
        [`distance(_rng1) == distance(_rng2) ? std::equal(_begin(_rng1), _end(_rng1), _begin(_rng2), _prd) : false`]
    ]
    [
        [`equals(_rng1, _rng2)`]
        [`equals(_rng1, _rng2, boost::lambda::_1 == boost::lambda::_2)`]
    ]
]

[endsect]




[section front/back]

[h3 Description]

[h3 Header]
* `<pstade/oven/front_back.hpp>`

[h3 Model of]
* _auxiliary_interface_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`front(_rng)`]
        [`*_begin(_rng)`]
    ]
    [
        [`back(_bidrng)`]
        [`*boost::prior(_bidrng)`]
    ]
]

[h3 Preconditions]
* `!boost::empty(_rng)`
* `!boost::empty(_bidrng)`
* Destruction of an iterator doesn't invalidate references previously obtained from that iterator.

[h3 See also]
* [link oven.value_front_value_back value_front/value_back]

[endsect]




[section value_at]

[h3 Description]

[h3 Header]
* `<pstade/oven/at.hpp>`

[h3 Model of]
* _auxiliary_interface_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`value_at(_rndrng, n)`]
        [`boost::range_value<_typeof(_rndrng)>::type(*(_begin(_rndrng) + n))`]
    ]
]

[h3 Preconditions]
* `boost::range_value<_typeof(_rndrng)>::type` is _copy_constructible_.
* `_typeof(n)` is convertible to `boost::range_difference<_typeof(_rndrng)>::type`.
* `0 <= n && n < distance(_rndrng)`

[h3 See also]
* [link oven.at at]

[endsect]




[section value_front/value_back]

[h3 Description]

[h3 Header]
* `<pstade/oven/front_back.hpp>`

[h3 Model of]
* _auxiliary_interface_

[h3 Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`value_front(_rng)`]
        [`boost::range_value<_typeof(_rng)>::type(*_begin(_rng))`]
    ]
    [
        [`value_back(_bidrng)`]
        [`boost::range_value<_typeof(_bidrng)>::type(*boost::prior(_bidrng))`]
    ]
]

[h3 Preconditions]
* `boost::range_value<_typeof(_rng)>::type` is _copy_constructible_.
* `boost::range_value<_typeof(_bidrng)>::type` is _copy_constructible_.
* `!boost::empty(_rng)`
* `!boost::empty(_bidrng)`

[h3 See also]
* [link oven.front_back front/back]

[endsect]




[endsect]
