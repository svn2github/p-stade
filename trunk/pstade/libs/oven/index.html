<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>The Oven Range Library</title>
<meta name="author" content="MB" />
<style type="text/css">

@import "http://p-stade.sourceforge.net/doc/boost.css";
@import "http://p-stade.sourceforge.net/doc/poost.css";

</style>
</head>
<body>
<div class="document" id="the-oven-range-library">
<h1 class="title">The Oven Range Library</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>MB</td></tr>
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first last reference" href="mailto:mb2act&#64;yahoo.co.jp">mb2act&#64;yahoo.co.jp</a></td></tr>
<tr class="field"><th class="docinfo-name">License:</th><td class="field-body">Distributed under the <a class="reference" href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License Version 1.0</a></td>
</tr>
<tr><th class="docinfo-name">Version:</th>
<td>0.90.5</td></tr>
</tbody>
</table>
<blockquote class="epigraph">
<p>&quot;<em>Oh Paulie!</em>&quot;</p>
<p class="attribution">&mdash;Adrian</p>
</blockquote>
<div class="contents topic">
<p class="topic-title first"><a id="table-of-contents" name="table-of-contents"><strong>Table of Contents</strong></a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#introduction" id="id11" name="id11">1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#requirements" id="id12" name="id12">2&nbsp;&nbsp;&nbsp;Requirements</a></li>
<li><a class="reference" href="#tested-under" id="id13" name="id13">3&nbsp;&nbsp;&nbsp;Tested Under</a></li>
<li><a class="reference" href="#range-algorithms" id="id14" name="id14">4&nbsp;&nbsp;&nbsp;Range Algorithms</a><ul class="auto-toc">
<li><a class="reference" href="#stl-algorithms" id="id15" name="id15">4.1&nbsp;&nbsp;&nbsp;STL Algorithms</a></li>
<li><a class="reference" href="#base-iterator" id="id16" name="id16">4.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">base_iterator</span></tt></a></li>
<li><a class="reference" href="#copied" id="id17" name="id17">4.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">copied</span></tt></a></li>
<li><a class="reference" href="#distance" id="id18" name="id18">4.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">distance</span></tt></a></li>
<li><a class="reference" href="#equals" id="id19" name="id19">4.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">equals</span></tt></a></li>
</ul>
</li>
<li><a class="reference" href="#ranges" id="id20" name="id20">5&nbsp;&nbsp;&nbsp;Ranges</a><ul class="auto-toc">
<li><a class="reference" href="#array-range" id="id21" name="id21">5.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">array_range</span></tt></a></li>
<li><a class="reference" href="#counting-range" id="id22" name="id22">5.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">counting_range</span></tt></a></li>
<li><a class="reference" href="#directory-range" id="id23" name="id23">5.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">directory_range</span></tt></a></li>
<li><a class="reference" href="#empty-range" id="id24" name="id24">5.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">empty_range</span></tt></a></li>
<li><a class="reference" href="#file-range" id="id25" name="id25">5.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">file_range</span></tt></a></li>
<li><a class="reference" href="#istream-range" id="id26" name="id26">5.6&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">istream_range</span></tt></a></li>
<li><a class="reference" href="#single-range" id="id27" name="id27">5.7&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">single_range</span></tt></a></li>
</ul>
</li>
<li><a class="reference" href="#range-adaptors" id="id28" name="id28">6&nbsp;&nbsp;&nbsp;Range Adaptors</a><ul class="auto-toc">
<li><a class="reference" href="#specification" id="id29" name="id29">6.1&nbsp;&nbsp;&nbsp;Specification</a></li>
<li><a class="reference" href="#adjacent-filtered" id="id30" name="id30">6.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">adjacent_filtered</span></tt></a></li>
<li><a class="reference" href="#always" id="id31" name="id31">6.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">always</span></tt></a></li>
<li><a class="reference" href="#appended" id="id32" name="id32">6.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">appended</span></tt></a></li>
<li><a class="reference" href="#applied" id="id33" name="id33">6.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">applied</span></tt></a></li>
<li><a class="reference" href="#array-protected" id="id34" name="id34">6.6&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">array_protected</span></tt></a></li>
<li><a class="reference" href="#checked" id="id35" name="id35">6.7&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">checked</span></tt></a></li>
<li><a class="reference" href="#cleared" id="id36" name="id36">6.8&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">cleared</span></tt></a></li>
<li><a class="reference" href="#constants" id="id37" name="id37">6.9&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">constants</span></tt></a></li>
<li><a class="reference" href="#copied-as-adaptor" id="id38" name="id38">6.10&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">copied</span></tt> as adaptor</a></li>
<li><a class="reference" href="#directed" id="id39" name="id39">6.11&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">directed</span></tt></a></li>
<li><a class="reference" href="#dropped" id="id40" name="id40">6.12&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">dropped</span></tt></a></li>
<li><a class="reference" href="#dropped-while" id="id41" name="id41">6.13&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">dropped_while</span></tt></a></li>
<li><a class="reference" href="#filtered" id="id42" name="id42">6.14&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">filtered</span></tt></a></li>
<li><a class="reference" href="#firsts" id="id43" name="id43">6.15&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">firsts</span></tt></a></li>
<li><a class="reference" href="#got-at" id="id44" name="id44">6.16&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">got_at</span></tt></a></li>
<li><a class="reference" href="#identities" id="id45" name="id45">6.17&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">identities</span></tt></a></li>
<li><a class="reference" href="#indirected" id="id46" name="id46">6.18&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">indirected</span></tt></a></li>
<li><a class="reference" href="#jointed" id="id47" name="id47">6.19&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">jointed</span></tt></a></li>
<li><a class="reference" href="#map-keys" id="id48" name="id48">6.20&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">map_keys</span></tt></a></li>
<li><a class="reference" href="#map-values" id="id49" name="id49">6.21&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">map_values</span></tt></a></li>
<li><a class="reference" href="#memoized" id="id50" name="id50">6.22&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">memoized</span></tt></a></li>
<li><a class="reference" href="#null-terminated" id="id51" name="id51">6.23&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">null_terminated</span></tt></a></li>
<li><a class="reference" href="#out-placed" id="id52" name="id52">6.24&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">out_placed</span></tt></a></li>
<li><a class="reference" href="#permuted" id="id53" name="id53">6.25&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">permuted</span></tt></a></li>
<li><a class="reference" href="#pointed" id="id54" name="id54">6.26&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">pointed</span></tt></a></li>
<li><a class="reference" href="#positioned" id="id55" name="id55">6.27&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">positioned</span></tt></a></li>
<li><a class="reference" href="#prepended" id="id56" name="id56">6.28&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">prepended</span></tt></a></li>
<li><a class="reference" href="#regularized" id="id57" name="id57">6.29&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">regularized</span></tt></a></li>
<li><a class="reference" href="#repeated" id="id58" name="id58">6.30&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">repeated</span></tt></a></li>
<li><a class="reference" href="#reversed" id="id59" name="id59">6.31&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">reversed</span></tt></a></li>
<li><a class="reference" href="#scanned" id="id60" name="id60">6.32&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">scanned</span></tt></a></li>
<li><a class="reference" href="#seconds" id="id61" name="id61">6.33&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">seconds</span></tt></a></li>
<li><a class="reference" href="#shared" id="id62" name="id62">6.34&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">shared</span></tt></a></li>
<li><a class="reference" href="#shifted" id="id63" name="id63">6.35&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">shifted</span></tt></a></li>
<li><a class="reference" href="#sliced" id="id64" name="id64">6.36&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">sliced</span></tt></a></li>
<li><a class="reference" href="#sorted" id="id65" name="id65">6.37&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">sorted</span></tt></a></li>
<li><a class="reference" href="#stridden" id="id66" name="id66">6.38&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">stridden</span></tt></a></li>
<li><a class="reference" href="#string-found" id="id67" name="id67">6.39&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">string_found</span></tt></a></li>
<li><a class="reference" href="#string-split" id="id68" name="id68">6.40&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">string_split</span></tt></a></li>
<li><a class="reference" href="#taken" id="id69" name="id69">6.41&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">taken</span></tt></a></li>
<li><a class="reference" href="#taken-while" id="id70" name="id70">6.42&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">taken_while</span></tt></a></li>
<li><a class="reference" href="#tokenized" id="id71" name="id71">6.43&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">tokenized</span></tt></a></li>
<li><a class="reference" href="#transformed" id="id72" name="id72">6.44&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">transformed</span></tt></a></li>
<li><a class="reference" href="#uniqued" id="id73" name="id73">6.45&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">uniqued</span></tt></a></li>
<li><a class="reference" href="#unzipped" id="id74" name="id74">6.46&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">unzipped</span></tt></a></li>
<li><a class="reference" href="#utf8-decoded" id="id75" name="id75">6.47&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">utf8_decoded</span></tt></a></li>
<li><a class="reference" href="#zipped" id="id76" name="id76">6.48&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">zipped</span></tt></a></li>
<li><a class="reference" href="#zipped-with" id="id77" name="id77">6.49&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">zipped_with</span></tt></a></li>
</ul>
</li>
<li><a class="reference" href="#acknowledgments" id="id78" name="id78">7&nbsp;&nbsp;&nbsp;Acknowledgments</a></li>
<li><a class="reference" href="#release-notes" id="id79" name="id79">8&nbsp;&nbsp;&nbsp;Release Notes</a><ul class="auto-toc">
<li><a class="reference" href="#version-0-90-0" id="id80" name="id80">8.1&nbsp;&nbsp;&nbsp;Version 0.90.0</a></li>
<li><a class="reference" href="#version-0-90-1" id="id81" name="id81">8.2&nbsp;&nbsp;&nbsp;Version 0.90.1</a></li>
<li><a class="reference" href="#version-0-90-2" id="id82" name="id82">8.3&nbsp;&nbsp;&nbsp;Version 0.90.2</a></li>
<li><a class="reference" href="#version-0-90-3" id="id83" name="id83">8.4&nbsp;&nbsp;&nbsp;Version 0.90.3</a></li>
<li><a class="reference" href="#version-0-90-4" id="id84" name="id84">8.5&nbsp;&nbsp;&nbsp;Version 0.90.4</a></li>
<li><a class="reference" href="#version-0-90-5" id="id85" name="id85">8.6&nbsp;&nbsp;&nbsp;Version 0.90.5</a></li>
</ul>
</li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id11" id="introduction" name="introduction">1&nbsp;&nbsp;&nbsp;Introduction</a></h1>
<p>Oven provides an experimental Range Adaptor implementation of <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>:</p>
<pre class="cpp_source">
std::vector&lt;<span class="cpp_keyword">char</span>&gt; out;

BOOST_FOREACH (<span class="cpp_keyword">char </span>ch,
    <span class="cpp_keyword">new </span>std::string(<span class="cpp_string_literal">&quot;!ExGNxxAR ,xOLxLExH&quot;</span>)
        | shared
        | filtered(lambda::_1 != <span class="cpp_string_literal">'x'</span>)
        | regularized
        | reversed
        | transformed(::to_lower)
        | memoized
) {
    out.push_back(ch);
}

BOOST_CHECK( oven::equals(out, <span class="cpp_string_literal">&quot;hello, range!&quot;</span>|null_terminated) );</pre>

<p>All the types and functions are defined in <tt class="docutils literal"><span class="pre">namespace</span> <span class="pre">pstade::oven</span></tt> at <tt class="docutils literal"><span class="pre">&lt;pstade/oven.hpp&gt;</span></tt>.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id12" id="requirements" name="requirements">2&nbsp;&nbsp;&nbsp;Requirements</a></h1>
<ul class="simple">
<li><a class="reference" href="http://www.boost.org/">Boost C++ Libraries Version 1.33.1</a> or later (no compilation required)</li>
<li><a class="reference" href="http://sourceforge.net/project/showfiles.php?group_id=141222&amp;package_id=173059">P-Stade C++ Libraries Version 1.00.5</a> or later (no compilation required, give a higher priority than Boost headers)</li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id13" id="tested-under" name="tested-under">3&nbsp;&nbsp;&nbsp;Tested Under</a></h1>
<ul class="simple">
<li>Microsoft Visual C++ 2005 Express Edition</li>
<li>Microsoft Visual C++ .NET Version 7.1</li>
<li>GCC 3.4.4</li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id14" id="range-algorithms" name="range-algorithms">4&nbsp;&nbsp;&nbsp;Range Algorithms</a></h1>
<p>Oven provides some range-based algorithms.
<tt class="docutils literal"><span class="pre">&lt;pstade/oven/functions.hpp&gt;</span></tt> includes all the following functions.</p>
<div class="section">
<h2><a class="toc-backref" href="#id15" id="stl-algorithms" name="stl-algorithms">4.1&nbsp;&nbsp;&nbsp;STL Algorithms</a></h2>
<p>Oven has all the range-based STL algorithms which are ported from <a class="reference" href="http://boost-consulting.com/vault/index.php?&amp;directory=Algorithms">Boost.RangeEx</a> with some compiler workarounds:</p>
<pre class="cpp_source">
std::string str;

<span class="cpp_comment">// iterator-based
</span>str = <span class="cpp_string_literal">&quot;gfedcba&quot;</span>;
std::sort(str.begin(), str.end());
BOOST_CHECK( str == <span class="cpp_string_literal">&quot;abcdefg&quot;</span> );

<span class="cpp_comment">// Oven range-based
</span>str = <span class="cpp_string_literal">&quot;gfedcba&quot;</span>;
oven::sort(str);
BOOST_CHECK( str == <span class="cpp_string_literal">&quot;abcdefg&quot;</span> );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/algorithm.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">oven::algo(rng,a0,a1,...,aN);</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">std::algo(boost::begin(rng),boost::end(rng),a0,a1,...,aN);</span></tt> is a valid expression, where <tt class="docutils literal"><span class="pre">algo</span></tt> is one of the STL algorithms.</li>
<li>Returns: <tt class="docutils literal"><span class="pre">std::algo(boost::begin(rng),boost::end(rng),a0,a1,...,aN);</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id16" id="base-iterator" name="base-iterator">4.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">base_iterator</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">base_iterator</span></tt> automatically gets the <tt class="docutils literal"><span class="pre">base_type</span></tt> iterator of adapted ranges:</p>
<pre class="cpp_source">
std::string src(<span class="cpp_string_literal">&quot;cjaigvwzenqhe&quot;</span>);
std::string::const_iterator it = oven::base_iterator(
    oven::max_element(
        src
            | filtered(lambda::_1 != <span class="cpp_string_literal">'z'</span>)
            | filtered(lambda::_1 != <span class="cpp_string_literal">'w'</span>)
            | regularized <span class="cpp_comment">// for non-assignability of lambda functors
    </span>)
);

BOOST_CHECK( *it == <span class="cpp_string_literal">'v'</span> );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/iterator_cast.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">base</span> <span class="pre">=</span> <span class="pre">oven::base_iterator(rng);</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id17" id="copied" name="copied">4.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">copied</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">copied</span></tt> adds the automatic type deduction to <a class="reference" href="http://www.boost.org/libs/range/doc/utility_class.html#copy_range">copy_range</a> which
calls the range constructor of the STL Sequences:</p>
<pre class="cpp_source">
std::vector&lt;<span class="cpp_keyword">int</span>&gt; vec = oven::make_counting_range(<span class="cpp_number_literal">3</span>, <span class="cpp_number_literal">9</span>)|copied;
vec.push_back(<span class="cpp_number_literal">9</span>);
BOOST_CHECK( oven::equals(vec, oven::make_counting_range(<span class="cpp_number_literal">3</span>, <span class="cpp_number_literal">10</span>)) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/copy_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">seq</span> <span class="pre">=</span> <span class="pre">rng|copied;</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">seq</span> <span class="pre">=</span> <span class="pre">boost::copy_range&lt;Seq&gt;(rng);</span></tt> is a valid expression.</li>
<li>Effect: <tt class="docutils literal"><span class="pre">seq</span> <span class="pre">=</span> <span class="pre">boost::copy_range&lt;Seq&gt;(rng);</span></tt></li>
</ul>
<p>Note that <tt class="docutils literal"><span class="pre">Seq</span> <span class="pre">seq(rng|copied);</span></tt> is not a valid expression.
<tt class="docutils literal"><span class="pre">copied</span></tt> is also one of the range <a class="reference" href="#copied-as-adaptor">adaptors</a>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id18" id="distance" name="distance">4.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">distance</span></tt></a></h2>
<p>The upcoming <a class="reference" href="http://www.boost.org/libs/range/">Boost.Range</a> will replace <tt class="docutils literal"><span class="pre">boost::size</span></tt> by <tt class="docutils literal"><span class="pre">boost::distance</span></tt>.
<tt class="docutils literal"><span class="pre">oven::distance</span></tt> that is the same as <tt class="docutils literal"><span class="pre">boost::distance</span></tt> makes your code portable:</p>
<pre class="cpp_source">
std::string str(<span class="cpp_string_literal">&quot;012345&quot;</span>);
BOOST_CHECK( oven::distance(str) == <span class="cpp_number_literal">6 </span>);</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/distance.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">oven::distance(rng);</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">std::distance(boost::begin(rng),boost::end(rng));</span></tt> is a valid expression.</li>
<li>Returns: <tt class="docutils literal"><span class="pre">std::distance(boost::begin(rng),boost::end(rng))</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id19" id="equals" name="equals">4.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">equals</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">equals</span></tt> is the range-based <tt class="docutils literal"><span class="pre">std::equal</span></tt> that takes two ranges as the arguments.
Note that the size of two ranges is also checked out:</p>
<pre class="cpp_source">
std::string str(<span class="cpp_string_literal">&quot;hello, equals&quot;</span>);
std::vector&lt;<span class="cpp_keyword">char</span>&gt; vec = str|copied;
BOOST_CHECK( oven::equals(str, vec) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/equals.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">oven::equals(rng1,rng2);</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">oven::equal(rng1,boost::begin(rng2));</span></tt> is a valid expression.</li>
<li>Returns: <tt class="docutils literal"><span class="pre">true</span></tt> if and only if the <tt class="docutils literal"><span class="pre">oven::equal(rng1,boost::begin(rng2))</span></tt> and <tt class="docutils literal"><span class="pre">boost::size(rng1)</span> <span class="pre">==</span> <span class="pre">boost::size(rng2)</span></tt> returns <tt class="docutils literal"><span class="pre">true</span></tt>.</li>
</ul>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id20" id="ranges" name="ranges">5&nbsp;&nbsp;&nbsp;Ranges</a></h1>
<p>Oven provides some predefined range types.
<tt class="docutils literal"><span class="pre">&lt;pstade/oven/ranges.hpp&gt;</span></tt> includes all the following ranges except for
<a class="reference" href="#directory-range">directory_range</a> and <a class="reference" href="#tokenized">tokenized</a>.</p>
<div class="section">
<h2><a class="toc-backref" href="#id21" id="array-range" name="array-range">5.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">array_range</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">array_range</span></tt> is a model of <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#random_access_range">Random Access Range</a> which delivers
a range presentation of dynamically allocated arrays:</p>
<pre class="cpp_source">
std::string str(<span class="cpp_string_literal">&quot;hello, array_range!&quot;</span>);
boost::array&lt;<span class="cpp_keyword">char</span>, <span class="cpp_number_literal">19</span>&gt; sarr;
str|copied(sarr);
oven::array_range&lt;<span class="cpp_keyword">char</span>&gt; darr(<span class="cpp_number_literal">19</span>);
str|copied(darr);

BOOST_CHECK( oven::equals(sarr, darr) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/array_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">array_range&lt;T&gt;</span> <span class="pre">rng(sz);</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">new</span> <span class="pre">T[sz];</span></tt> is a valid expression.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id22" id="counting-range" name="counting-range">5.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">counting_range</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">counting_range</span></tt> is a range whose iterators behave as if
they were the original iterators wrapped in <a class="reference" href="http://www.boost.org/libs/iterator/doc/counting_iterator.html">counting_iterator</a>:</p>
<pre class="cpp_source">
<span class="cpp_keyword">int </span>ans[] = { <span class="cpp_number_literal">2</span>, <span class="cpp_number_literal">3</span>, <span class="cpp_number_literal">4</span>, <span class="cpp_number_literal">5</span>, <span class="cpp_number_literal">6 </span>};
BOOST_CHECK( oven::equal(oven::make_counting_range(<span class="cpp_number_literal">2</span>, <span class="cpp_number_literal">7</span>), ans) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/counting_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">counting_range&lt;I,T,D&gt;</span> <span class="pre">rng(n,m);</span></tt> and <tt class="docutils literal"><span class="pre">oven::make_counting_range(n,m);</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">boost::couting_iterator&lt;I,T,D&gt;(x);</span></tt> is a valid expression, where
<tt class="docutils literal"><span class="pre">x</span></tt> is <tt class="docutils literal"><span class="pre">n</span></tt> or <tt class="docutils literal"><span class="pre">m</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id23" id="directory-range" name="directory-range">5.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">directory_range</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">directory_range</span></tt> is a range whose iterators behave as if
they were the original iterators wrapped in <a class="reference" href="http://www.boost.org/libs/filesystem/doc/operations.htm#directory_iterator">directory_iterator</a>:</p>
<pre class="cpp_source">
BOOST_FOREACH (
    filesystem::path <span class="cpp_keyword">const</span>&amp; pt,
    directory_range(filesystem::current_path()))
{
    std::cout &lt;&lt; pt.leaf() &lt;&lt; std::endl;
}</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/directory_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">directory_range</span> <span class="pre">rng(p);</span></tt> and <tt class="docutils literal"><span class="pre">wdirectory_range</span> <span class="pre">wrng(wp);</span></tt></li>
<li>Precondition: The type of <tt class="docutils literal"><span class="pre">p</span></tt> is <tt class="docutils literal"><span class="pre">boost::filesystem::path</span></tt> and
the type of <tt class="docutils literal"><span class="pre">wp</span></tt> is <tt class="docutils literal"><span class="pre">boost::filesystem::wpath</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id24" id="empty-range" name="empty-range">5.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">empty_range</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">empty_range</span></tt> is a <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#random_access_range">Random Access Range</a> which is always empty:</p>
<pre class="cpp_source">
BOOST_CHECK( boost::empty(empty_range&lt;<span class="cpp_keyword">int</span>&gt;()) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/empty_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">empty_range&lt;T&gt;</span> <span class="pre">rng;</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id25" id="file-range" name="file-range">5.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">file_range</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">file_range</span></tt> is a range whose iterators behave as if they were the original iterators wrapped in <a class="reference" href="http://www.boost.org/libs/spirit/doc/file_iterator.html">file_iterator</a>.
The member <tt class="docutils literal"><span class="pre">is_open()</span></tt> returns <tt class="docutils literal"><span class="pre">true</span></tt> if and only if the file opening is succeeded.
If <tt class="docutils literal"><span class="pre">is_open()</span></tt> is not <tt class="docutils literal"><span class="pre">true</span></tt>, the range is empty:</p>
<pre class="cpp_source">
std::vector&lt;<span class="cpp_keyword">char</span>&gt; vec;
oven::copy(file_range&lt;<span class="cpp_keyword">char</span>&gt;(<span class="cpp_string_literal">&quot;data.txt&quot;</span>), std::back_inserter(vec));</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/file_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">file_range&lt;C&gt;</span> <span class="pre">rng;</span></tt> and <tt class="docutils literal"><span class="pre">rng.is_open();</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">boost::spirit::file_iterator&lt;C&gt;</span></tt> is a valid expression.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id26" id="istream-range" name="istream-range">5.6&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">istream_range</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">istream_range</span></tt> is a range whose iterators behave as if they were the original iterators wrapped in <a class="reference" href="http://www.sgi.com/tech/stl/istream_iterator.html">istream_iterator</a>:</p>
<pre class="cpp_source">
std::string src(<span class="cpp_string_literal">&quot;hello,istream_range!&quot;</span>);

std::stringstream ss;
ss &lt;&lt; src;

std::string result;
oven::copy(oven::make_istream_range&lt;<span class="cpp_keyword">char</span>&gt;(ss), std::back_inserter(result));

BOOST_CHECK( oven::equals(result, src) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/istream_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">istream_range&lt;V,C,T,D&gt;</span> <span class="pre">rng(stm);</span></tt> and  <tt class="docutils literal"><span class="pre">oven::make_istream_range&lt;V&gt;(stm);</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">std::istream_iterator&lt;V,C,T,D&gt;(stm)</span></tt> is a valid expression.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id27" id="single-range" name="single-range">5.7&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">single_range</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">single_range</span></tt> is a <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#random_access_range">Random Access Range</a> which delivers a range presentation of one object:</p>
<pre class="cpp_source">
BOOST_CHECK( oven::equals(oven::make_single_range(<span class="cpp_string_literal">'a'</span>), std::string(<span class="cpp_string_literal">&quot;a&quot;</span>)) );
</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/single_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">single_range&lt;T&gt;</span> <span class="pre">rng(v);</span></tt> and <tt class="docutils literal"><span class="pre">oven::make_single_range(v)</span></tt></li>
<li>Precondition: The type of <tt class="docutils literal"><span class="pre">v</span></tt> is <tt class="docutils literal"><span class="pre">T</span></tt>.</li>
</ul>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id28" id="range-adaptors" name="range-adaptors">6&nbsp;&nbsp;&nbsp;Range Adaptors</a></h1>
<p>A Range Adaptor delivers an altered presentation of one or more underlying ranges.
Range Adaptors are lazy, meaning that their elements are only computed on demand.
The underlying ranges are not modified.
Additional information is available at <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.
<tt class="docutils literal"><span class="pre">&lt;pstade/oven/ranges.hpp&gt;</span></tt> includes all the following Range Adaptors.</p>
<div class="section">
<h2><a class="toc-backref" href="#id29" id="specification" name="specification">6.1&nbsp;&nbsp;&nbsp;Specification</a></h2>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">rng</span></tt>: any range</li>
<li><tt class="docutils literal"><span class="pre">fwdRng</span></tt>: any <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#forward_range">Forward Range</a></li>
<li><tt class="docutils literal"><span class="pre">biRng</span></tt>: any <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#bidirectional_range">Bidirectional Range</a></li>
<li><tt class="docutils literal"><span class="pre">rndRng</span></tt>: any <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#random_access_range">Random Access Range</a></li>
<li><tt class="docutils literal"><span class="pre">pred</span></tt>: any <a class="reference" href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a></li>
<li><tt class="docutils literal"><span class="pre">rfun</span></tt>: any <a class="reference" href="http://www.sgi.com/tech/stl/functors.html">Functor</a> which can be used with <tt class="docutils literal"><span class="pre">boost::result_of</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id30" id="adjacent-filtered" name="adjacent-filtered">6.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">adjacent_filtered</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">adjacent_filtered</span></tt> returns a range whose adjacent pairs are filtered by using a <a class="reference" href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>:</p>
<pre class="cpp_source">
<span class="cpp_keyword">int </span>src[] = { <span class="cpp_number_literal">2</span>, <span class="cpp_number_literal">2</span>, <span class="cpp_number_literal">4</span>, <span class="cpp_number_literal">4</span>, <span class="cpp_number_literal">6</span>, <span class="cpp_number_literal">8</span>, <span class="cpp_number_literal">8</span>, <span class="cpp_number_literal">10</span>, <span class="cpp_number_literal">10</span>, <span class="cpp_number_literal">20</span>, <span class="cpp_number_literal">40</span>, <span class="cpp_number_literal">80</span>, <span class="cpp_number_literal">120 </span>};
<span class="cpp_keyword">int </span>answer[] = { <span class="cpp_number_literal">2</span>, <span class="cpp_number_literal">6</span>, <span class="cpp_number_literal">8</span>, <span class="cpp_number_literal">10</span>, <span class="cpp_number_literal">120 </span>};

BOOST_CHECK( oven::equals(
    src|adjacent_filtered(::not_divisor()),
    answer
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/adjacent_filter_range.hpp&gt;</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id31" id="always" name="always">6.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">always</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">always</span></tt> returns a range which does not change as its adapting range vary:</p>
<pre class="cpp_source">
BOOST_CHECK( oven::equals(
    std::string(<span class="cpp_string_literal">&quot;labor&quot;</span>)
        | jointed(std::string(<span class="cpp_string_literal">&quot;will be&quot;</span>))
        | always(<span class="cpp_string_literal">&quot;lost&quot;</span>),
    std::string(<span class="cpp_string_literal">&quot;lost&quot;</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/always_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">unusedRng|always(rng)</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::begin(rng),boost::end(rng))</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id32" id="appended" name="appended">6.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">appended</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">appended</span></tt> returns a range which is appended with its argument:</p>
<pre class="cpp_source">
std::string <span class="cpp_keyword">const </span>str(<span class="cpp_string_literal">&quot;hello, appen&quot;</span>);

BOOST_CHECK( oven::equals(
    str|appended(<span class="cpp_string_literal">'d'</span>)|appended(<span class="cpp_string_literal">'e'</span>)|appended(<span class="cpp_string_literal">'d'</span>)|appended(<span class="cpp_string_literal">'!'</span>),
    std::string(<span class="cpp_string_literal">&quot;hello, appended!&quot;</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/append_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|appended(v)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">v*</span></tt> is convertible to the <tt class="docutils literal"><span class="pre">iterator</span></tt> type of <tt class="docutils literal"><span class="pre">rng</span></tt>.</li>
<li>Returns: <tt class="docutils literal"><span class="pre">rng|jointed(oven::make_single_range(v))</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id33" id="applied" name="applied">6.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">applied</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">applied</span></tt> returns a range which is adapting by using functors.
<tt class="docutils literal"><span class="pre">applied</span></tt> is intended to be used with Boost.Phoenix version2.</p>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/apply_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|applied(f1,f2)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">f1(rng)</span></tt> and <tt class="docutils literal"><span class="pre">f2(rng)</span></tt> return iterators that are convertible to <tt class="docutils literal"><span class="pre">rng</span></tt>'s.</li>
<li>Returns: <tt class="docutils literal"><span class="pre">[f1(rng),f2(rng))</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id34" id="array-protected" name="array-protected">6.6&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">array_protected</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/array_protect_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">arr|array_protected</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">arr</span></tt> is an array.</li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::begin(arr),boost::begin(arr)+sz)</span></tt>, where <tt class="docutils literal"><span class="pre">sz</span></tt> is the size of <tt class="docutils literal"><span class="pre">arr</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id35" id="checked" name="checked">6.7&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">checked</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">checked</span></tt> adds the bounds checking ability to its adapting range:</p>
<pre class="cpp_source">
std::string in(<span class="cpp_string_literal">&quot;012345&quot;</span>);
std::string out(<span class="cpp_string_literal">&quot;01234&quot;</span>);

<span class="cpp_keyword">try </span>{
    oven::copy(in, boost::begin(out|checked));
}
<span class="cpp_keyword">catch </span>(check_error <span class="cpp_keyword">const</span>&amp; ) {
    <span class="cpp_keyword">return</span>;
}

BOOST_CHECK(<span class="cpp_keyword">false</span>);</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/check_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|checked</span></tt></li>
<li>Effect: Throws <tt class="docutils literal"><span class="pre">check_error</span></tt> derived from <tt class="docutils literal"><span class="pre">std::range_error</span></tt> if iterators go out of <tt class="docutils literal"><span class="pre">rng</span></tt>.</li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::begin(rng),boost::end(rng))</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id36" id="cleared" name="cleared">6.8&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">cleared</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">cleared</span></tt> returns a range which is always empty:</p>
<pre class="cpp_source">
BOOST_CHECK( boost::empty(
    std::string(<span class="cpp_string_literal">&quot;labor&quot;</span>)
        | jointed(std::string(<span class="cpp_string_literal">&quot;lost&quot;</span>))
        | cleared
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/clear_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|cleared</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::end(rng),boost::end(rng))</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id37" id="constants" name="constants">6.9&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">constants</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">constants</span></tt> returns a range whose iterators dereference cannot be modified:</p>
<pre class="cpp_source">
<span class="cpp_keyword">template</span>&lt; <span class="cpp_keyword">class </span>Range &gt;
<span class="cpp_keyword">void </span>modify(Range&amp; rng)
{
    *boost::begin(rng) = <span class="cpp_string_literal">'y'</span>; <span class="cpp_comment">// error!
</span>}

<span class="cpp_keyword">void </span>test()
{
    std::string str1(<span class="cpp_string_literal">&quot;hello, constant_range!&quot;</span>);
    ::modify(str1|constants);
}</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/constant_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|constants(rng)</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id38" id="copied-as-adaptor" name="copied-as-adaptor">6.10&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">copied</span></tt> as adaptor</a></h2>
<p><tt class="docutils literal"><span class="pre">copied</span></tt> makes a side-effect that copies its adapting range to its argument:</p>
<pre class="cpp_source">
std::string src(<span class="cpp_string_literal">&quot;axaxaxbxbxbx&quot;</span>);
std::string snapshot;
std::string answer(<span class="cpp_string_literal">&quot;bbb&quot;</span>);

BOOST_CHECK( oven::equals(
    src
        | filtered(lambda::_1 != <span class="cpp_string_literal">'x'</span>)
        | regularized
        | copied(std::back_inserter(snapshot))
        | filtered(lambda::_1 != <span class="cpp_string_literal">'a'</span>)
        | regularized,
    answer
) );

BOOST_CHECK( snapshot == <span class="cpp_string_literal">&quot;aaabbb&quot;</span> );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/copy_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|copied(it)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">oven::copy(rng,it)</span></tt> is a valid expression.</li>
<li>Effect: <tt class="docutils literal"><span class="pre">oven::copy(rng,it)</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::begin(rng),boost::end(rng))</span></tt> if <tt class="docutils literal"><span class="pre">rng</span></tt> is a <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#forward_range">Forward Range</a>; otherwise, <tt class="docutils literal"><span class="pre">void</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id39" id="directed" name="directed">6.11&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">directed</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">directed</span></tt> returns a range whose values are iterators of its adapting range:</p>
<pre class="cpp_source">
std::string <span class="cpp_keyword">const </span>str(<span class="cpp_string_literal">&quot;gefadcb&quot;</span>);
std::string <span class="cpp_keyword">const </span>answer(<span class="cpp_string_literal">&quot;abcdefg&quot;</span>);

std::vector&lt;std::string::const_iterator&gt; iters;
oven::copy(str|directed, std::back_inserter(iters));
oven::sort( iters, boost::make_indirect_fun(::less_than()) );

BOOST_CHECK( oven::equals(iters|indirected, answer) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/direct_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|directed</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">oven::make_counting_range(boost::begin(rng),</span> <span class="pre">boost::end(rng))</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id40" id="dropped" name="dropped">6.12&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">dropped</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">dropped</span></tt> returns the suffix of its adapting range after the first <tt class="docutils literal"><span class="pre">n</span></tt> elements:</p>
<pre class="cpp_source">
BOOST_CHECK( oven::equals(
    std::string(<span class="cpp_string_literal">&quot;hello, dropped!&quot;</span>)|dropped(<span class="cpp_number_literal">7</span>),
    std::string(<span class="cpp_string_literal">&quot;dropped!&quot;</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/drop_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|dropped(n)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&amp;&amp;</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">oven::distance(rng)</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">[f,boost::end(rng))</span></tt>, where <tt class="docutils literal"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">boost::begin(rng);</span> <span class="pre">std::advance(f,n);</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id41" id="dropped-while" name="dropped-while">6.13&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">dropped_while</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">dropped_while</span></tt> returns the remaining suffix of its adapting range of elements that satisfy <a class="reference" href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>:</p>
<pre class="cpp_source">
std::string src(<span class="cpp_string_literal">&quot;11111234516313!&quot;</span>);

BOOST_CHECK( oven::equals(
    src|dropped_while(lambda::_1 == <span class="cpp_string_literal">'1'</span>),
    std::string(<span class="cpp_string_literal">&quot;234516313!&quot;</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/drop_while_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|dropped_while(pred)</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">[f,boost::end(rng))</span></tt>, where <tt class="docutils literal"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">oven::find_if(f,not_(pred));</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id42" id="filtered" name="filtered">6.14&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">filtered</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">filtered</span></tt> returns a range which is filtered by using a <a class="reference" href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>:</p>
<pre class="cpp_source">
<span class="cpp_keyword">int </span>src[]    = { <span class="cpp_number_literal">2</span>,<span class="cpp_number_literal">5</span>,<span class="cpp_number_literal">2</span>,<span class="cpp_number_literal">6</span>,<span class="cpp_number_literal">1</span>,<span class="cpp_number_literal">3</span>,<span class="cpp_number_literal">2 </span>};
<span class="cpp_keyword">int </span>answer[] = { <span class="cpp_number_literal">0</span>,<span class="cpp_number_literal">5</span>,<span class="cpp_number_literal">0</span>,<span class="cpp_number_literal">6</span>,<span class="cpp_number_literal">1</span>,<span class="cpp_number_literal">3</span>,<span class="cpp_number_literal">0 </span>};

BOOST_FOREACH (<span class="cpp_keyword">int</span>&amp; i, src|filtered(lambda::_1 == <span class="cpp_number_literal">2</span>)|regularized) {
    i = <span class="cpp_number_literal">0</span>;
}

BOOST_CHECK( oven::equals(answer, src) );</pre>

<p>Note that a non-assignable lambda functor makes <tt class="docutils literal"><span class="pre">filtered</span></tt> non-conforming, so
it needs <a class="reference" href="#regularized">regularized</a> that makes it assignable and then conforming.</p>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/filter_range.hpp&gt;</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id43" id="firsts" name="firsts">6.15&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">firsts</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/first_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|firsts</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">rng|map_keys</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id44" id="got-at" name="got-at">6.16&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">got_at</span></tt></a></h2>
<p>Pending...</p>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/get_at_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|got_at&lt;N&gt;()</span></tt>, where <tt class="docutils literal"><span class="pre">value_type</span></tt> of <tt class="docutils literal"><span class="pre">rng</span></tt> is a Fusion Sequence.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id45" id="identities" name="identities">6.17&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">identities</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">identities</span></tt> returns a range which is identical to its adapting range:</p>
<pre class="cpp_source">
BOOST_CHECK( oven::equals(
    std::string(<span class="cpp_string_literal">&quot;hello, identities!&quot;</span>)|identities,
    std::string(<span class="cpp_string_literal">&quot;hello, identities!&quot;</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/identity_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|identities</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::begin(rng),boost::end(rng))</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id46" id="indirected" name="indirected">6.18&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">indirected</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">indirected</span></tt> adapts its adapting range by applying an extra dereference inside of <tt class="docutils literal"><span class="pre">operator*()</span></tt>:</p>
<pre class="cpp_source">
<span class="cpp_keyword">int </span>src[]    = { <span class="cpp_number_literal">1</span>,<span class="cpp_number_literal">2</span>,<span class="cpp_number_literal">0</span>,<span class="cpp_number_literal">4</span>,<span class="cpp_number_literal">5 </span>};
<span class="cpp_keyword">int </span>answer[] = { <span class="cpp_number_literal">1</span>,<span class="cpp_number_literal">2</span>,<span class="cpp_number_literal">3</span>,<span class="cpp_number_literal">4</span>,<span class="cpp_number_literal">5 </span>};
<span class="cpp_keyword">int </span>*ptrs[]  = {&amp;src[<span class="cpp_number_literal">0</span>],&amp;src[<span class="cpp_number_literal">1</span>],&amp;src[<span class="cpp_number_literal">2</span>],&amp;src[<span class="cpp_number_literal">3</span>],&amp;src[<span class="cpp_number_literal">4</span>]};

BOOST_FOREACH (<span class="cpp_keyword">int</span>&amp; i, ptrs|indirected) {
    <span class="cpp_keyword">if </span>(i == <span class="cpp_number_literal">0</span>)
        i = <span class="cpp_number_literal">3</span>;
}

BOOST_CHECK( oven::equals(src, answer) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/indirect_range.hpp&gt;</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id47" id="jointed" name="jointed">6.19&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">jointed</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">jointed</span></tt> returns a range which is jointed with its argument:</p>
<pre class="cpp_source">
std::string str0(<span class="cpp_string_literal">&quot;every range&quot;</span>);
std::vector&lt;<span class="cpp_keyword">char</span>&gt; str1 = std::string(<span class="cpp_string_literal">&quot; is&quot;</span>)|copied;
std::list&lt;<span class="cpp_keyword">char</span>&gt; str2 = std::string(<span class="cpp_string_literal">&quot; string!?&quot;</span>)|copied;

BOOST_CHECK( oven::equals(
    str0|jointed(str1)|jointed(str2),
    std::string(<span class="cpp_string_literal">&quot;every range is string!?&quot;</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/joint_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng1|jointed(rng2)</span></tt></li>
<li>Precondition: The <tt class="docutils literal"><span class="pre">iterator</span></tt> <tt class="docutils literal"><span class="pre">reference</span></tt> type of <tt class="docutils literal"><span class="pre">rng2</span></tt> is convertible to <tt class="docutils literal"><span class="pre">rng1</span></tt>'s.</li>
<li>Returns: A range that joints <tt class="docutils literal"><span class="pre">[boost::begin(rng1),boost::end(rng1))</span></tt> and <tt class="docutils literal"><span class="pre">[boost::begin(rng2),boost::end(rng2))</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id48" id="map-keys" name="map-keys">6.20&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">map_keys</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">map_keys</span></tt> returns a range whose values are the keys of its adapting associative container:</p>
<pre class="cpp_source">
std::map&lt;<span class="cpp_keyword">int</span>, std::string&gt; m;
m[<span class="cpp_number_literal">12</span>] = <span class="cpp_string_literal">&quot;hello&quot;</span>;
m[<span class="cpp_number_literal">4</span>]  = <span class="cpp_string_literal">&quot;map&quot;</span>;
m[<span class="cpp_number_literal">99</span>] = <span class="cpp_string_literal">&quot;keys&quot;</span>;

BOOST_FOREACH (<span class="cpp_keyword">int </span>k, m|map_keys) {
    BOOST_CHECK( k != <span class="cpp_number_literal">12 </span>|| m[k] == <span class="cpp_string_literal">&quot;hello&quot;</span> );
    BOOST_CHECK( k != <span class="cpp_number_literal">4  </span>|| m[k] == <span class="cpp_string_literal">&quot;map&quot;</span> );
    BOOST_CHECK( k != <span class="cpp_number_literal">99 </span>|| m[k] == <span class="cpp_string_literal">&quot;keys&quot;</span> );
}</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/map_key_range.hpp&gt;</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id49" id="map-values" name="map-values">6.21&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">map_values</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">map_values</span></tt> returns a range whose values are the mapped values of its adapting associative container:</p>
<pre class="cpp_source">
std::map&lt;<span class="cpp_keyword">int</span>, std::string&gt; m;
m[<span class="cpp_number_literal">12</span>] = <span class="cpp_string_literal">&quot;hello&quot;</span>;
m[<span class="cpp_number_literal">4</span>]  = <span class="cpp_string_literal">&quot;map&quot;</span>;
m[<span class="cpp_number_literal">99</span>] = <span class="cpp_string_literal">&quot;keys&quot;</span>;

BOOST_FOREACH (std::string&amp; v, m|map_values) {
    <span class="cpp_keyword">if </span>(v == <span class="cpp_string_literal">&quot;keys&quot;</span>)
        v = <span class="cpp_string_literal">&quot;values&quot;</span>;
}

BOOST_CHECK( m[<span class="cpp_number_literal">12</span>] == <span class="cpp_string_literal">&quot;hello&quot;</span> );
BOOST_CHECK( m[<span class="cpp_number_literal">4</span>]  == <span class="cpp_string_literal">&quot;map&quot;</span> );
BOOST_CHECK( m[<span class="cpp_number_literal">99</span>] == <span class="cpp_string_literal">&quot;values&quot;</span> );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/map_value_range.hpp&gt;</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id50" id="memoized" name="memoized">6.22&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">memoized</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">memoized</span></tt> returns a range whose values are cached for speed, preparing repeated dereferences.
Note that <tt class="docutils literal"><span class="pre">memoized</span></tt> can return a <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#forward_range">Forward Range</a> even if its adapting range is a <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#single_pass_range">Single Pass Range</a>:</p>
<pre class="cpp_source">
std::stringstream ss;
ss &lt;&lt; <span class="cpp_string_literal">&quot;hello, memoized!&quot;</span>;

::very_complicated_algorithm(
    oven::make_istream_range&lt;<span class="cpp_keyword">char</span>&gt;(ss)
        | memoized
        | directed
        | indirected
        | sorted
        | memoized
);</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/memoize_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|memoized</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">rng</span></tt> is referentially transparent.</li>
<li>Returns: A <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#forward_range">Forward Range</a> whose values are memoized.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id51" id="null-terminated" name="null-terminated">6.23&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">null_terminated</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/null_terminate_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">fwdRngOrString|null_terminated</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">rngOrString</span></tt> is a string literal; otherwise, for all the value <tt class="docutils literal"><span class="pre">v</span></tt> in the <tt class="docutils literal"><span class="pre">fwdRngOrString</span></tt>, the expression <tt class="docutils literal"><span class="pre">v</span> <span class="pre">==</span> <span class="pre">0</span></tt> must be valid, and some <tt class="docutils literal"><span class="pre">v</span></tt> that the expression is <tt class="docutils literal"><span class="pre">true</span></tt> exists in the <tt class="docutils literal"><span class="pre">fwdRngOrString</span></tt>.</li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::begin(fwdRngOrString),y)</span></tt>, where for all the value <tt class="docutils literal"><span class="pre">v</span></tt> in the range <tt class="docutils literal"><span class="pre">v</span> <span class="pre">!=</span> <span class="pre">0</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt>, and <tt class="docutils literal"><span class="pre">*y</span> <span class="pre">==</span> <span class="pre">0</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id52" id="out-placed" name="out-placed">6.24&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">out_placed</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">out_placed</span></tt> converts its adapting range to a <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#random_access_range">Random Access Range</a> by using temporary iterator container:</p>
<pre class="cpp_source">
std::list&lt;<span class="cpp_keyword">char</span>&gt; lst;
oven::copy(std::string(<span class="cpp_string_literal">&quot;cfbadehg&quot;</span>), std::back_inserter(lst));

oven::sort(lst|out_placed);
BOOST_CHECK( oven::equals(lst, std::string(<span class="cpp_string_literal">&quot;abcdefgh&quot;</span>)) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/out_place_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">fwdRng|out_placed</span></tt></li>
<li>Returns: A <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#random_access_range">Random Access Range</a> representing <tt class="docutils literal"><span class="pre">[boost::begin(fwdRng),boost::end(fwdRng))</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id53" id="permuted" name="permuted">6.25&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">permuted</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/permute_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rndRng|permuted(rng)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">rng</span></tt> is a range of the indices of <tt class="docutils literal"><span class="pre">rndRng</span></tt>.</li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <tt class="docutils literal"><span class="pre">boost::permutation_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id54" id="pointed" name="pointed">6.26&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">pointed</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">pointed</span></tt> provides an interface to have a conversation with legacy APIs:</p>
<pre class="cpp_source">
std::string <span class="cpp_keyword">const </span>src(<span class="cpp_string_literal">&quot;hello, point_range&quot;</span>);
std::vector&lt;<span class="cpp_keyword">char</span>&gt; vec;
vec.resize(oven::distance(src) + <span class="cpp_number_literal">1</span>);
std::strcpy(boost::begin(vec|pointed), src.c_str());
BOOST_CHECK(( oven::equals(vec|null_terminated, src) ));</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/point_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">vec|pointed</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">vec</span></tt> is a template instantiation of <tt class="docutils literal"><span class="pre">std::vector</span></tt>.</li>
<li>Returns:  <tt class="docutils literal"><span class="pre">[&amp;*boost::begin(vec),&amp;*boost::begin(vec)+oven::distance(vec))</span></tt> if <tt class="docutils literal"><span class="pre">vec</span></tt> is not empty; otherwise, <tt class="docutils literal"><span class="pre">[0,0)</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id55" id="positioned" name="positioned">6.27&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">positioned</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/position_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|positioned</span></tt></li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <tt class="docutils literal"><span class="pre">boost::spirit::position_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id56" id="prepended" name="prepended">6.28&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">prepended</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/prepend_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|prepended(v)</span></tt></li>
<li>Precondition: The <tt class="docutils literal"><span class="pre">iterator</span></tt> type of <tt class="docutils literal"><span class="pre">rng</span></tt> is convertible to <tt class="docutils literal"><span class="pre">v*</span></tt>.</li>
<li>Returns: <tt class="docutils literal"><span class="pre">oven::make_single_range(v)|jointed(rng)</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id57" id="regularized" name="regularized">6.29&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">regularized</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/regularize_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|regularized</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::begin(rng),boost::end(rng))</span></tt>, which is a conforming range, even if iterators of <tt class="docutils literal"><span class="pre">rng</span></tt> are not assignable.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id58" id="repeated" name="repeated">6.30&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">repeated</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/repeat_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|repeated(n)</span></tt></li>
<li>Returns: A range that repeats <tt class="docutils literal"><span class="pre">[boost::begin(rng),boost::end(rng))</span></tt> <tt class="docutils literal"><span class="pre">n</span></tt> times.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id59" id="reversed" name="reversed">6.31&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">reversed</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/reverse_range.hpp&gt;</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id60" id="scanned" name="scanned">6.32&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">scanned</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">scanned</span></tt> is similar to <tt class="docutils literal"><span class="pre">oven::accumulate</span></tt>, but returns a range of successive reduced values from its adapting range:</p>
<pre class="cpp_source">
std::string stringize(std::string <span class="cpp_keyword">const</span>&amp; state, <span class="cpp_keyword">int </span>i)
{
    <span class="cpp_keyword">return </span>state + boost::lexical_cast&lt;std::string&gt;(i);
}

<span class="cpp_keyword">void </span>test()
{
    <span class="cpp_keyword">int </span><span class="cpp_keyword">const </span>src[] = { <span class="cpp_number_literal">1</span>,<span class="cpp_number_literal">2</span>,<span class="cpp_number_literal">3</span>,<span class="cpp_number_literal">4</span>,<span class="cpp_number_literal">5 </span>};

    BOOST_FOREACH (std::string str, src|scanned(std::string(), ::stringize)) {
        std::cout &lt;&lt; <span class="cpp_string_literal">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="cpp_string_literal">&quot;\&quot; &quot;</span>;
    }
    <span class="cpp_comment">// outputs: &quot;1&quot; &quot;12&quot; &quot;123&quot; &quot;1234&quot; &quot;12345&quot;
</span>}</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/scan_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|scanned(init,fun)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">fun(s,r)</span></tt> is a valid expression, where the type of <tt class="docutils literal"><span class="pre">s</span></tt> is the same as <tt class="docutils literal"><span class="pre">init</span></tt> and <tt class="docutils literal"><span class="pre">r</span></tt> is the iterator dereference of <tt class="docutils literal"><span class="pre">rng</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id61" id="seconds" name="seconds">6.33&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">seconds</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/second_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|seconds</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">rng|map_values</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id62" id="shared" name="shared">6.34&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">shared</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/share_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">new</span> <span class="pre">Range|shared</span></tt></li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <tt class="docutils literal"><span class="pre">boost::shared_container_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id63" id="shifted" name="shifted">6.35&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">shifted</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/shift_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">fwdRng|shifted(d)</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">fwdRng|sliced(d,d)</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id64" id="sliced" name="sliced">6.36&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">sliced</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/slice_range.hpp&gt;</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id65" id="sorted" name="sorted">6.37&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">sorted</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">sorted</span></tt> provides the out-place sorting. Note that <tt class="docutils literal"><span class="pre">sorted</span></tt> doesn't modify its adapting range.</p>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/sort_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">fwdRng|sorted</span></tt> or <tt class="docutils literal"><span class="pre">fwdRng|sorted(pred)</span></tt></li>
<li>Returns: A sorted view of <tt class="docutils literal"><span class="pre">fwdRng</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id66" id="stridden" name="stridden">6.38&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">stridden</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">stridden</span></tt> provides the column view of its adapting range:</p>
<pre class="cpp_source">
<span class="cpp_keyword">int </span><span class="cpp_keyword">const </span>answer[] = { <span class="cpp_number_literal">2</span>,<span class="cpp_number_literal">6</span>,<span class="cpp_number_literal">10</span>,<span class="cpp_number_literal">14 </span>};
BOOST_CHECK( oven::equals(answer,
    oven::make_counting_range(<span class="cpp_number_literal">0</span>, <span class="cpp_number_literal">16</span>)|stridden(<span class="cpp_number_literal">4</span>, <span class="cpp_number_literal">2</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/stride_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">fwdRng|stridden(l,o)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">d</span> <span class="pre">%</span> <span class="pre">l</span> <span class="pre">==</span> <span class="pre">0</span> <span class="pre">||</span> <span class="pre">d</span> <span class="pre">%</span> <span class="pre">l</span> <span class="pre">==</span> <span class="pre">l</span></tt> and <tt class="docutils literal"><span class="pre">o</span> <span class="pre">&lt;</span> <span class="pre">l</span></tt>, where <tt class="docutils literal"><span class="pre">d</span> <span class="pre">=</span> <span class="pre">oven::distance(fwdRng);</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id67" id="string-found" name="string-found">6.39&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">string_found</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/string_find_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|string_found(finder)</span></tt></li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <tt class="docutils literal"><span class="pre">boost::algorithm::find_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id68" id="string-split" name="string-split">6.40&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">string_split</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/string_split_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|string_split(finder)</span></tt></li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <tt class="docutils literal"><span class="pre">boost::algorithm::split_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id69" id="taken" name="taken">6.41&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">taken</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">taken</span></tt>, applied to its adapting range, returns the prefix of the range of length <tt class="docutils literal"><span class="pre">n</span></tt>:</p>
<pre class="cpp_source">
std::string src(<span class="cpp_string_literal">&quot;hello, take_range!&quot;</span>);
std::string ans(<span class="cpp_string_literal">&quot;hello&quot;</span>);
BOOST_CHECK( oven::equals(src|taken(<span class="cpp_number_literal">7</span>)|taken(<span class="cpp_number_literal">5</span>), ans) );
</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/take_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">fwdRng|taken(n)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">n</span> <span class="pre">&amp;&amp;</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">oven::distance(rng)</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::begin(fwdRng),l)</span></tt>, where <tt class="docutils literal"><span class="pre">l</span> <span class="pre">=</span> <span class="pre">boost::begin(fwdRng);</span> <span class="pre">std::advance(l,n);</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id70" id="taken-while" name="taken-while">6.42&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">taken_while</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">taken_while</span></tt>, applied to a <a class="reference" href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a> and its adapting range, returns the longest
prefix (possibly empty) of the range of elements that satisfy <a class="reference" href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>:</p>
<pre class="cpp_source">
std::string src(<span class="cpp_string_literal">&quot;11111234516313!&quot;</span>);

BOOST_CHECK( oven::equals(
    src|taken_while(lambda::_1 == <span class="cpp_string_literal">'1'</span>),
    std::string(<span class="cpp_string_literal">&quot;11111&quot;</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/take_while_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">fwdRng|taken_while(pred)</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::begin(fwdRng),oven::find_if(fwdRng,not_(pred)))</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id71" id="tokenized" name="tokenized">6.43&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">tokenized</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/token_range.hpp&gt;</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id72" id="transformed" name="transformed">6.44&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">transformed</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/transorm_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|transformed(rfun)</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id73" id="uniqued" name="uniqued">6.45&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">uniqued</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/unique_range.hpp&gt;</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id74" id="unzipped" name="unzipped">6.46&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">unzipped</span></tt></a></h2>
<p>Pending...</p>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/unzip_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">zipped_rng|unzipped_at&lt;N&gt;</span></tt> or <tt class="docutils literal"><span class="pre">zipped_range|unzipped</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">N</span></tt> is a integral constant specifying the index.</li>
<li>Returns: A range which is unzipped the <a class="reference" href="#zipped">zipped</a> range.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id75" id="utf8-decoded" name="utf8-decoded">6.47&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">utf8_decoded</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/utf8_decode_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">biRng|utf8_decoded</span></tt></li>
<li>Returns: A <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#bidirectional_range">Bidirectional Range</a> whose iterators behave as if they were the original iterators wrapped in <tt class="docutils literal"><span class="pre">boost::u8_to_u32_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id76" id="zipped" name="zipped">6.48&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">zipped</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">zipped</span></tt> takes two range and returns a range of corresponding tuples.
If one input range is short, excess elements of the longer range are discarded.</p>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/zip_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng0|zipped(rng1)</span></tt></li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <tt class="docutils literal"><span class="pre">boost::zip_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id77" id="zipped-with" name="zipped-with">6.49&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">zipped_with</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">zipped_with</span></tt> generalises <tt class="docutils literal"><span class="pre">zipped</span></tt> by zipping with the functor,
given as the first argument, instead of a tupling:</p>
<pre class="cpp_source">
<span class="cpp_keyword">int </span>xs[]  = { <span class="cpp_number_literal">0</span>, <span class="cpp_number_literal">1</span>, <span class="cpp_number_literal">2</span>, <span class="cpp_number_literal">3</span>, <span class="cpp_number_literal">4</span>, <span class="cpp_number_literal">5</span>, <span class="cpp_number_literal">6 </span>};
<span class="cpp_keyword">int </span>ys[]  = { <span class="cpp_number_literal">1</span>, <span class="cpp_number_literal">6</span>, <span class="cpp_number_literal">1</span>, <span class="cpp_number_literal">2</span>, <span class="cpp_number_literal">7</span>, <span class="cpp_number_literal">8</span>, <span class="cpp_number_literal">3 </span>};
<span class="cpp_keyword">int </span>ans[] = { <span class="cpp_number_literal">1</span>, <span class="cpp_number_literal">7</span>, <span class="cpp_number_literal">3</span>, <span class="cpp_number_literal">5</span>,<span class="cpp_number_literal">11</span>,<span class="cpp_number_literal">13</span>, <span class="cpp_number_literal">9 </span>};

BOOST_CHECK( oven::equals(
    xs|zipped_with(ys, ::plus()),
    ans
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/zip_with_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng0|zipped_with(rng1,</span> <span class="pre">rfun)</span></tt></li>
<li>Returns: A range whose values are zipped by using <tt class="docutils literal"><span class="pre">rfun</span></tt>.</li>
</ul>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id78" id="acknowledgments" name="acknowledgments">7&nbsp;&nbsp;&nbsp;Acknowledgments</a></h1>
<ul class="simple">
<li><a class="reference" href="http://p-stade.sourceforge.net/">P-Stade</a></li>
<li><a class="reference" href="http://www.boost.org/">Boost C++ Libraries</a></li>
<li><a class="reference" href="http://www.boost.org/libs/range/">Boost.Range</a></li>
<li><a class="reference" href="http://boost-consulting.com/vault/index.php?&amp;directory=Algorithms">Boost.RangeEx</a></li>
<li><a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a></li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id79" id="release-notes" name="release-notes">8&nbsp;&nbsp;&nbsp;Release Notes</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id80" id="version-0-90-0" name="version-0-90-0">8.1&nbsp;&nbsp;&nbsp;Version 0.90.0</a></h2>
<ul class="simple">
<li>Released initial version.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id81" id="version-0-90-1" name="version-0-90-1">8.2&nbsp;&nbsp;&nbsp;Version 0.90.1</a></h2>
<ul class="simple">
<li>Updated this document.</li>
<li>Implemented <a class="reference" href="#range-algorithms">Range Algorithms</a>.</li>
<li>Added some <a class="reference" href="#ranges">Ranges</a> and <a class="reference" href="#range-adaptors">Range Adaptors</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id82" id="version-0-90-2" name="version-0-90-2">8.3&nbsp;&nbsp;&nbsp;Version 0.90.2</a></h2>
<ul class="simple">
<li>Added some <a class="reference" href="#range-adaptors">Range Adaptors</a>.</li>
<li>Changed the header of <a class="reference" href="#permuted">permuted</a>.</li>
<li>Changed the header of <a class="reference" href="#pointed">pointed</a>.</li>
<li>Changed a valid expression of <a class="reference" href="#zipped">zipped</a>.</li>
<li>Changed <a class="reference" href="#checked">checked</a> to throw exception.</li>
<li>Renamed <tt class="docutils literal"><span class="pre">found</span></tt> to <a class="reference" href="#string-found">string_found</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id83" id="version-0-90-3" name="version-0-90-3">8.4&nbsp;&nbsp;&nbsp;Version 0.90.3</a></h2>
<ul class="simple">
<li>Changed the header of <a class="reference" href="#range-algorithms">Range Algorithms</a>.</li>
<li>Added <a class="reference" href="#base-iterator">base_iterator</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id84" id="version-0-90-4" name="version-0-90-4">8.5&nbsp;&nbsp;&nbsp;Version 0.90.4</a></h2>
<ul class="simple">
<li>Added some <a class="reference" href="#range-adaptors">Range Adaptors</a>.</li>
<li>Renamed <tt class="docutils literal"><span class="pre">accumulated</span></tt> to <a class="reference" href="#scanned">scanned</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id85" id="version-0-90-5" name="version-0-90-5">8.6&nbsp;&nbsp;&nbsp;Version 0.90.5</a></h2>
<ul class="simple">
<li>Added workaround for <a class="reference" href="http://std.dkuug.dk/jtc1/sc22/wg21/docs/lwg-defects.html#198">Standard Library Defect #198</a>.</li>
<li>Changed <a class="reference" href="#constants">constants</a> semantics, and added <a class="reference" href="#always">always</a> instead.</li>
</ul>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="doc/index.rst">View document source</a>.
Generated on: 2006-07-31 16:40 UTC.
Generated by <a class="reference" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
