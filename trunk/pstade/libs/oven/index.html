<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>The Oven Range Library</title>
<meta name="author" content="Shunsuke Sogame" />
<style type="text/css">

@import "http://p-stade.sourceforge.net/doc/boost.css";
@import "http://p-stade.sourceforge.net/doc/poost.css";

</style>
</head>
<body>
<div class="document" id="the-oven-range-library">
<h1 class="title">The Oven Range Library</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Shunsuke Sogame</td></tr>
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first last reference" href="mailto:pstade.mb&#64;gmail.com">pstade.mb&#64;gmail.com</a></td></tr>
<tr class="field"><th class="docinfo-name">License:</th><td class="field-body">Distributed under the <a class="reference" href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License Version 1.0</a></td>
</tr>
<tr><th class="docinfo-name">Version:</th>
<td>0.93.3</td></tr>
</tbody>
</table>
<blockquote class="epigraph">
<p>&quot;<em>Oh Paulie!</em>&quot;</p>
<p class="attribution">&mdash;Adrian</p>
</blockquote>
<div class="contents topic">
<p class="topic-title first"><a id="table-of-contents" name="table-of-contents"><strong>Table of Contents</strong></a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#introduction" id="id51" name="id51">1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#requirements" id="id52" name="id52">2&nbsp;&nbsp;&nbsp;Requirements</a></li>
<li><a class="reference" href="#tested-under" id="id53" name="id53">3&nbsp;&nbsp;&nbsp;Tested Under</a></li>
<li><a class="reference" href="#specification" id="id54" name="id54">4&nbsp;&nbsp;&nbsp;Specification</a></li>
<li><a class="reference" href="#range-algorithms" id="id55" name="id55">5&nbsp;&nbsp;&nbsp;Range Algorithms</a><ul class="auto-toc">
<li><a class="reference" href="#stl-algorithms" id="id56" name="id56">5.1&nbsp;&nbsp;&nbsp;STL Algorithms</a></li>
<li><a class="reference" href="#adapted-to-to-base" id="id57" name="id57">5.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">adapted_to/to_base</span></tt></a></li>
<li><a class="reference" href="#begin-end" id="id58" name="id58">5.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">begin/end</span></tt></a></li>
<li><a class="reference" href="#compile" id="id59" name="id59">5.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">compile</span></tt></a></li>
<li><a class="reference" href="#copied" id="id60" name="id60">5.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">copied</span></tt></a></li>
<li><a class="reference" href="#distance" id="id61" name="id61">5.6&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">distance</span></tt></a></li>
<li><a class="reference" href="#equals" id="id62" name="id62">5.7&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">equals</span></tt></a></li>
<li><a class="reference" href="#front-back" id="id63" name="id63">5.8&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">front/back</span></tt></a></li>
</ul>
</li>
<li><a class="reference" href="#utilities" id="id64" name="id64">6&nbsp;&nbsp;&nbsp;Utilities</a><ul class="auto-toc">
<li><a class="reference" href="#innumerable" id="id65" name="id65">6.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">innumerable</span></tt></a></li>
<li><a class="reference" href="#regular" id="id66" name="id66">6.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">regular</span></tt></a></li>
<li><a class="reference" href="#shared-regular" id="id67" name="id67">6.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">shared_regular</span></tt></a></li>
</ul>
</li>
<li><a class="reference" href="#ranges" id="id68" name="id68">7&nbsp;&nbsp;&nbsp;Ranges</a><ul class="auto-toc">
<li><a class="reference" href="#any-range" id="id69" name="id69">7.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">any_range</span></tt></a></li>
<li><a class="reference" href="#array-range" id="id70" name="id70">7.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">array_range</span></tt></a></li>
<li><a class="reference" href="#directory-range" id="id71" name="id71">7.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">directory_range</span></tt></a></li>
<li><a class="reference" href="#empty-range" id="id72" name="id72">7.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">empty_range</span></tt></a></li>
<li><a class="reference" href="#file-range" id="id73" name="id73">7.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">file_range</span></tt></a></li>
</ul>
</li>
<li><a class="reference" href="#range-makers" id="id74" name="id74">8&nbsp;&nbsp;&nbsp;Range Makers</a><ul class="auto-toc">
<li><a class="reference" href="#as-array" id="id75" name="id75">8.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">as_array</span></tt></a></li>
<li><a class="reference" href="#as-c-str" id="id76" name="id76">8.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">as_c_str</span></tt></a></li>
<li><a class="reference" href="#as-literal" id="id77" name="id77">8.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">as_literal</span></tt></a></li>
<li><a class="reference" href="#as-single" id="id78" name="id78">8.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">as_single</span></tt></a></li>
<li><a class="reference" href="#as-shared-single" id="id79" name="id79">8.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">as_shared_single</span></tt></a></li>
<li><a class="reference" href="#counting" id="id80" name="id80">8.6&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">counting</span></tt></a></li>
<li><a class="reference" href="#counting-from" id="id81" name="id81">8.7&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">counting_from</span></tt></a></li>
<li><a class="reference" href="#generation" id="id82" name="id82">8.8&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">generation</span></tt></a></li>
<li><a class="reference" href="#indexing" id="id83" name="id83">8.9&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">indexing</span></tt></a></li>
<li><a class="reference" href="#iteration" id="id84" name="id84">8.10&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">iteration</span></tt></a></li>
<li><a class="reference" href="#recursion" id="id85" name="id85">8.11&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">recursion</span></tt></a></li>
<li><a class="reference" href="#repeated" id="id86" name="id86">8.12&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">repeated</span></tt></a></li>
<li><a class="reference" href="#stream-input" id="id87" name="id87">8.13&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">stream_input</span></tt></a></li>
<li><a class="reference" href="#streambuf-input" id="id88" name="id88">8.14&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">streambuf_input</span></tt></a></li>
</ul>
</li>
<li><a class="reference" href="#range-adaptors" id="id89" name="id89">9&nbsp;&nbsp;&nbsp;Range Adaptors</a><ul class="auto-toc">
<li><a class="reference" href="#adjacent-filtered" id="id90" name="id90">9.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">adjacent_filtered</span></tt></a></li>
<li><a class="reference" href="#adjacent-transformed" id="id91" name="id91">9.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">adjacent_transformed</span></tt></a></li>
<li><a class="reference" href="#advanced" id="id92" name="id92">9.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">advanced</span></tt></a></li>
<li><a class="reference" href="#always" id="id93" name="id93">9.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">always</span></tt></a></li>
<li><a class="reference" href="#appended" id="id94" name="id94">9.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">appended</span></tt></a></li>
<li><a class="reference" href="#applied" id="id95" name="id95">9.6&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">applied</span></tt></a></li>
<li><a class="reference" href="#broken-into" id="id96" name="id96">9.7&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">broken_into</span></tt></a></li>
<li><a class="reference" href="#checked" id="id97" name="id97">9.8&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">checked</span></tt></a></li>
<li><a class="reference" href="#cleared" id="id98" name="id98">9.9&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">cleared</span></tt></a></li>
<li><a class="reference" href="#concatenated" id="id99" name="id99">9.10&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">concatenated</span></tt></a></li>
<li><a class="reference" href="#constants" id="id100" name="id100">9.11&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">constants</span></tt></a></li>
<li><a class="reference" href="#const-lvalues" id="id101" name="id101">9.12&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">const_lvalues</span></tt></a></li>
<li><a class="reference" href="#copied-out" id="id102" name="id102">9.13&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">copied_out</span></tt></a></li>
<li><a class="reference" href="#cycled" id="id103" name="id103">9.14&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">cycled</span></tt></a></li>
<li><a class="reference" href="#delimited" id="id104" name="id104">9.15&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">delimited</span></tt></a></li>
<li><a class="reference" href="#directed" id="id105" name="id105">9.16&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">directed</span></tt></a></li>
<li><a class="reference" href="#dropped" id="id106" name="id106">9.17&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">dropped</span></tt></a></li>
<li><a class="reference" href="#dropped-while" id="id107" name="id107">9.18&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">dropped_while</span></tt></a></li>
<li><a class="reference" href="#filtered" id="id108" name="id108">9.19&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">filtered</span></tt></a></li>
<li><a class="reference" href="#firsts" id="id109" name="id109">9.20&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">firsts</span></tt></a></li>
<li><a class="reference" href="#got-at" id="id110" name="id110">9.21&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">got_at</span></tt></a></li>
<li><a class="reference" href="#identities" id="id111" name="id111">9.22&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">identities</span></tt></a></li>
<li><a class="reference" href="#indirected" id="id112" name="id112">9.23&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">indirected</span></tt></a></li>
<li><a class="reference" href="#jointed" id="id113" name="id113">9.24&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">jointed</span></tt></a></li>
<li><a class="reference" href="#map-keys" id="id114" name="id114">9.25&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">map_keys</span></tt></a></li>
<li><a class="reference" href="#map-values" id="id115" name="id115">9.26&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">map_values</span></tt></a></li>
<li><a class="reference" href="#matches" id="id116" name="id116">9.27&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">matches</span></tt></a></li>
<li><a class="reference" href="#memoized" id="id117" name="id117">9.28&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">memoized</span></tt></a></li>
<li><a class="reference" href="#merged" id="id118" name="id118">9.29&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">merged</span></tt></a></li>
<li><a class="reference" href="#permuted" id="id119" name="id119">9.30&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">permuted</span></tt></a></li>
<li><a class="reference" href="#pointed" id="id120" name="id120">9.31&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">pointed</span></tt></a></li>
<li><a class="reference" href="#popped" id="id121" name="id121">9.32&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">popped</span></tt></a></li>
<li><a class="reference" href="#prepended" id="id122" name="id122">9.33&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">prepended</span></tt></a></li>
<li><a class="reference" href="#reversed" id="id123" name="id123">9.34&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">reversed</span></tt></a></li>
<li><a class="reference" href="#rotated" id="id124" name="id124">9.35&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">rotated</span></tt></a></li>
<li><a class="reference" href="#scanned" id="id125" name="id125">9.36&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">scanned</span></tt></a></li>
<li><a class="reference" href="#seconds" id="id126" name="id126">9.37&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">seconds</span></tt></a></li>
<li><a class="reference" href="#set-cap" id="id127" name="id127">9.38&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">set_cap</span></tt></a></li>
<li><a class="reference" href="#set-cup" id="id128" name="id128">9.39&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">set_cup</span></tt></a></li>
<li><a class="reference" href="#set-delta" id="id129" name="id129">9.40&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">set_delta</span></tt></a></li>
<li><a class="reference" href="#set-minus" id="id130" name="id130">9.41&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">set_minus</span></tt></a></li>
<li><a class="reference" href="#shared" id="id131" name="id131">9.42&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">shared</span></tt></a></li>
<li><a class="reference" href="#sliced" id="id132" name="id132">9.43&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">sliced</span></tt></a></li>
<li><a class="reference" href="#string-found" id="id133" name="id133">9.44&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">string_found</span></tt></a></li>
<li><a class="reference" href="#string-split" id="id134" name="id134">9.45&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">string_split</span></tt></a></li>
<li><a class="reference" href="#taken" id="id135" name="id135">9.46&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">taken</span></tt></a></li>
<li><a class="reference" href="#taken-while" id="id136" name="id136">9.47&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">taken_while</span></tt></a></li>
<li><a class="reference" href="#tokenized" id="id137" name="id137">9.48&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">tokenized</span></tt></a></li>
<li><a class="reference" href="#transformed" id="id138" name="id138">9.49&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">transformed</span></tt></a></li>
<li><a class="reference" href="#uniqued" id="id139" name="id139">9.50&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">uniqued</span></tt></a></li>
<li><a class="reference" href="#unzipped" id="id140" name="id140">9.51&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">unzipped</span></tt></a></li>
<li><a class="reference" href="#utf8-decoded" id="id141" name="id141">9.52&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">utf8_decoded</span></tt></a></li>
<li><a class="reference" href="#window" id="id142" name="id142">9.53&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">window</span></tt></a></li>
<li><a class="reference" href="#with-position" id="id143" name="id143">9.54&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">with_position</span></tt></a></li>
<li><a class="reference" href="#xpressive-matches" id="id144" name="id144">9.55&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">xpressive_matches</span></tt></a></li>
<li><a class="reference" href="#xpressive-tokenized" id="id145" name="id145">9.56&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">xpressive_tokenized</span></tt></a></li>
<li><a class="reference" href="#zipped" id="id146" name="id146">9.57&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">zipped</span></tt></a></li>
<li><a class="reference" href="#zipped-with" id="id147" name="id147">9.58&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">zipped_with</span></tt></a></li>
</ul>
</li>
<li><a class="reference" href="#output-iterator-adaptors" id="id148" name="id148">10&nbsp;&nbsp;&nbsp;Output Iterator Adaptors</a><ul class="auto-toc">
<li><a class="reference" href="#to-counter" id="id149" name="id149">10.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">to_counter</span></tt></a></li>
<li><a class="reference" href="#to-function" id="id150" name="id150">10.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">to_function</span></tt></a></li>
<li><a class="reference" href="#to-stream" id="id151" name="id151">10.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">to_stream</span></tt></a></li>
<li><a class="reference" href="#to-utf8-encoder" id="id152" name="id152">10.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">to_utf8_encoder</span></tt></a></li>
</ul>
</li>
<li><a class="reference" href="#extending-boost-range" id="id153" name="id153">11&nbsp;&nbsp;&nbsp;Extending Boost.Range</a></li>
<li><a class="reference" href="#mfc-atl-extension" id="id154" name="id154">12&nbsp;&nbsp;&nbsp;MFC/ATL Extension</a></li>
<li><a class="reference" href="#acknowledgments" id="id155" name="id155">13&nbsp;&nbsp;&nbsp;Acknowledgments</a></li>
<li><a class="reference" href="#release-notes" id="id156" name="id156">14&nbsp;&nbsp;&nbsp;Release Notes</a><ul class="auto-toc">
<li><a class="reference" href="#version-0-90-0" id="id157" name="id157">14.1&nbsp;&nbsp;&nbsp;Version 0.90.0</a></li>
<li><a class="reference" href="#version-0-90-1-0-90-6" id="id158" name="id158">14.2&nbsp;&nbsp;&nbsp;Version 0.90.1 - 0.90.6</a></li>
<li><a class="reference" href="#version-0-90-7-0-90-9" id="id159" name="id159">14.3&nbsp;&nbsp;&nbsp;Version 0.90.7 - 0.90.9</a></li>
<li><a class="reference" href="#version-0-91-0-0-91-3" id="id160" name="id160">14.4&nbsp;&nbsp;&nbsp;Version 0.91.0 - 0.91.3</a></li>
<li><a class="reference" href="#version-0-91-4-0-91-9" id="id161" name="id161">14.5&nbsp;&nbsp;&nbsp;Version 0.91.4 - 0.91.9</a></li>
<li><a class="reference" href="#version-0-92-0-0-92-3" id="id162" name="id162">14.6&nbsp;&nbsp;&nbsp;Version 0.92.0 - 0.92.3</a></li>
<li><a class="reference" href="#version-0-93-0" id="id163" name="id163">14.7&nbsp;&nbsp;&nbsp;Version 0.93.0</a></li>
<li><a class="reference" href="#version-0-93-1" id="id164" name="id164">14.8&nbsp;&nbsp;&nbsp;Version 0.93.1</a></li>
<li><a class="reference" href="#version-0-93-2" id="id165" name="id165">14.9&nbsp;&nbsp;&nbsp;Version 0.93.2</a></li>
<li><a class="reference" href="#version-0-93-3" id="id166" name="id166">14.10&nbsp;&nbsp;&nbsp;Version 0.93.3</a></li>
</ul>
</li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id51" id="introduction" name="introduction">1&nbsp;&nbsp;&nbsp;Introduction</a></h1>
<p>Oven provides an experimental Range Adaptor implementation of <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>:</p>
<pre class="cpp_source">
<span class="cpp_keyword">typedef
    </span>any_range&lt;<span class="cpp_keyword">int</span>, boost::single_pass_traversal_tag&gt;
range;

range sieve(range rng)
{
    <span class="cpp_keyword">return </span>rng|dropped(<span class="cpp_number_literal">1</span>)|filtered(regular(lambda::_1 % front(rng) != <span class="cpp_number_literal">0</span>));
}

range primes
    = iteration(range(counting_from(<span class="cpp_number_literal">2</span>)), &amp;::sieve)|transformed(front);

<span class="cpp_keyword">int </span>main()
{
    std::cout &lt;&lt; (primes|taken(<span class="cpp_number_literal">200</span>));
}
</pre>

<p>All the types and functions are defined in <tt class="docutils literal"><span class="pre">namespace</span> <span class="pre">pstade::oven</span></tt> at <tt class="docutils literal"><span class="pre">&lt;pstade/oven.hpp&gt;</span></tt>
unless otherwise specified.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id52" id="requirements" name="requirements">2&nbsp;&nbsp;&nbsp;Requirements</a></h1>
<ul class="simple">
<li><a class="reference" href="http://www.boost.org/">Boost C++ Libraries Version 1.33.1</a> or later (no compilation required)</li>
<li><a class="reference" href="http://sourceforge.net/project/showfiles.php?group_id=141222&amp;package_id=173059">P-Stade C++ Libraries Version 1.02.0</a> or later (no compilation required, give a higher priority than Boost headers)</li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id53" id="tested-under" name="tested-under">3&nbsp;&nbsp;&nbsp;Tested Under</a></h1>
<ul class="simple">
<li>Microsoft Visual C++ 2005 Express Edition SP1</li>
<li>Microsoft Visual C++ .NET Version 7.1 SP1</li>
<li>GCC 3.4.4</li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id54" id="specification" name="specification">4&nbsp;&nbsp;&nbsp;Specification</a></h1>
<p>This document is based on the following specifications.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">rng</span></tt>: any range</li>
<li><tt class="docutils literal"><span class="pre">fwdRng</span></tt>: any <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#forward_range">Forward Range</a></li>
<li><tt class="docutils literal"><span class="pre">biRng</span></tt>: any <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#bidirectional_range">Bidirectional Range</a></li>
<li><tt class="docutils literal"><span class="pre">rndRng</span></tt>: any <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#random_access_range">Random Access Range</a></li>
<li><tt class="docutils literal"><span class="pre">pred</span></tt>: any <a class="reference" href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a></li>
<li><tt class="docutils literal"><span class="pre">rfun</span></tt>: any <a class="reference" href="http://www.sgi.com/tech/stl/functors.html">Function Object</a> <a class="footnote-reference" href="#id6" id="id5" name="id5">[1]</a> which can be used with <tt class="docutils literal"><span class="pre">boost::result_of</span></tt>.</li>
<li>If <tt class="docutils literal"><span class="pre">xxx(a1,..,aN)</span></tt> is a valid expression and <tt class="docutils literal"><span class="pre">xxx</span></tt> is not a type name, <tt class="docutils literal"><span class="pre">xxx</span></tt> is a <a class="reference" href="http://www.sgi.com/tech/stl/functors.html">Function Object</a>
whose type name is <tt class="docutils literal"><span class="pre">op_xxx</span></tt> to support <tt class="docutils literal"><span class="pre">boost::result_of</span></tt> and Boost.Lambda.</li>
</ul>
<pre class="cpp_source">
std::string src(<span class="cpp_string_literal">&quot;hello, specification&quot;</span>);

boost::result_of&lt;op_make_filtered(std::string&amp;, <span class="cpp_keyword">bool</span>(*)(<span class="cpp_keyword">char</span>))&gt;::type
    result = make_filtered(src, &amp;is_upper);
BOOST_CHECK( equals(result, src|filtered(&amp;is_upper)) );</pre>

<p>All the ranges Oven defines are <tt class="docutils literal"><span class="pre">InputStreamable</span></tt> and <tt class="docutils literal"><span class="pre">OutputStreamable</span></tt> if <tt class="docutils literal"><span class="pre">&lt;pstade/oven/io.hpp&gt;</span></tt> is included.</p>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5" name="id6">[1]</a></td><td>The function type is not supported as <tt class="docutils literal"><span class="pre">rfun</span></tt>. Instead, add <tt class="docutils literal"><span class="pre">&amp;</span></tt> to make a function <strong>pointer</strong>.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id55" id="range-algorithms" name="range-algorithms">5&nbsp;&nbsp;&nbsp;Range Algorithms</a></h1>
<p>Oven provides some range-based algorithms.
<tt class="docutils literal"><span class="pre">&lt;pstade/oven/functions.hpp&gt;</span></tt> includes all the following functions unless otherwise specified.</p>
<div class="section">
<h2><a class="toc-backref" href="#id56" id="stl-algorithms" name="stl-algorithms">5.1&nbsp;&nbsp;&nbsp;STL Algorithms</a></h2>
<p>Oven has all the range-based STL algorithms, which are ported from <a class="reference" href="http://boost-consulting.com/vault/index.php?&amp;directory=Algorithms">Boost.RangeEx</a> with some compiler workarounds:</p>
<pre class="cpp_source">
std::string str;

<span class="cpp_comment">// iterator-based
</span>str = <span class="cpp_string_literal">&quot;gfedcba&quot;</span>;
std::sort(str.begin(), str.end());
BOOST_CHECK( str == <span class="cpp_string_literal">&quot;abcdefg&quot;</span> );

<span class="cpp_comment">// Oven range-based
</span>str = <span class="cpp_string_literal">&quot;gfedcba&quot;</span>;
oven::sort(str);
BOOST_CHECK( str == <span class="cpp_string_literal">&quot;abcdefg&quot;</span> );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/algorithm.hpp&gt;</span></tt> and <tt class="docutils literal"><span class="pre">&lt;pstade/oven/numeric.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">algo(rng,a0,a1,..,aN)</span></tt>, where <tt class="docutils literal"><span class="pre">algo</span></tt> is a <a class="reference" href="http://www.sgi.com/tech/stl/functors.html">Function Object</a>.</li>
<li>Precondition: <tt class="docutils literal"><span class="pre">std::algo(boost::begin(rng),boost::end(rng),a0,a1,..,aN)</span></tt> is a valid expression, where <tt class="docutils literal"><span class="pre">algo</span></tt> is one of the STL algorithms.</li>
<li>Returns: <tt class="docutils literal"><span class="pre">std::algo(boost::begin(rng),boost::end(rng),a0,a1,..,aN)</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id57" id="adapted-to-to-base" name="adapted-to-to-base">5.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">adapted_to/to_base</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">adapted_to</span></tt> gets the <tt class="docutils literal"><span class="pre">base_type</span></tt> iterator of adapted iterators:</p>
<pre class="cpp_source">
std::string src(<span class="cpp_string_literal">&quot;cjaigvwzenqhe&quot;</span>);
std::string::iterator it = oven::adapted_to&lt;std::string::iterator&gt;(
    oven::max_element(
        src
            | filtered(regular(lambda::_1 != <span class="cpp_string_literal">'z'</span>))
            | filtered(regular(lambda::_1 != <span class="cpp_string_literal">'w'</span>))
    )
);

BOOST_CHECK( *it == <span class="cpp_string_literal">'v'</span> );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/adapted_to_base.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">base</span> <span class="pre">=</span> <span class="pre">oven::adapted_to&lt;BaseIter&gt;(it);</span></tt> or <tt class="docutils literal"><span class="pre">BaseIter</span> <span class="pre">base</span> <span class="pre">=</span> <span class="pre">it|to_base;</span></tt> <a class="footnote-reference" href="#id8" id="id7" name="id7">[2]</a></li>
<li>Precondition: The type of <tt class="docutils literal"><span class="pre">base</span></tt> is <tt class="docutils literal"><span class="pre">BaseIter</span></tt>, and <tt class="docutils literal"><span class="pre">it</span></tt> is an adapted iterator.</li>
</ul>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7" name="id8">[2]</a></td><td><tt class="docutils literal"><span class="pre">to_base</span></tt> adds the automatic type deduction to <tt class="docutils literal"><span class="pre">adapted_to</span></tt>.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id58" id="begin-end" name="begin-end">5.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">begin/end</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">begin/end</span></tt> is a pipable version of <tt class="docutils literal"><span class="pre">boost::begin/end</span></tt>:</p>
<pre class="cpp_source">
std::string src(<span class="cpp_string_literal">&quot;abcDefg&quot;</span>);   
oven::copy(src|reversed|transformed(to_upper), src|reversed|begin);
BOOST_CHECK( oven::equals(src, std::string(<span class="cpp_string_literal">&quot;ABCDEFG&quot;</span>)) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/begin_end.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|begin</span></tt> and <tt class="docutils literal"><span class="pre">rng|end</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">boost::begin(rng)</span></tt> and <tt class="docutils literal"><span class="pre">boost::end(rng)</span></tt> is a valid expression.</li>
<li>Returns: <tt class="docutils literal"><span class="pre">boost::begin(rng)</span></tt> and <tt class="docutils literal"><span class="pre">boost::end(rng)</span></tt> respectively.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id59" id="compile" name="compile">5.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">compile</span></tt></a></h2>
<p><cite>Pending...</cite></p>
<p><tt class="docutils literal"><span class="pre">compile</span></tt> introduces the syntax sugar for <tt class="docutils literal"><span class="pre">jointed</span></tt> etc:</p>
<pre class="cpp_source">
std::string       rng1(<span class="cpp_string_literal">&quot;12&quot;</span>);
std::list&lt;<span class="cpp_keyword">char</span>&gt;   rng2 = std::string(<span class="cpp_string_literal">&quot;34&quot;</span>)|copied;
std::vector&lt;<span class="cpp_keyword">char</span>&gt; rng3 = std::string(<span class="cpp_string_literal">&quot;56&quot;</span>)|copied;

BOOST_CHECK( equals(
    compile( +(rng1 &gt;&gt; (rng2|as_term) &gt;&gt; rng3) ) | taken(<span class="cpp_number_literal">17</span>),
    std::string(<span class="cpp_string_literal">&quot;12345612345612345&quot;</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/compile.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">compile(rngExpr)</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id60" id="copied" name="copied">5.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">copied</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">copied</span></tt> adds the automatic type deduction to <a class="reference" href="http://www.boost.org/libs/range/doc/utility_class.html#copy_range">copy_range</a> which
calls the range constructor of the STL Sequences:</p>
<pre class="cpp_source">
std::vector&lt;<span class="cpp_keyword">int</span>&gt; vec = oven::counting(<span class="cpp_number_literal">3</span>, <span class="cpp_number_literal">9</span>)|copied;
vec.push_back(<span class="cpp_number_literal">9</span>);
BOOST_CHECK( oven::equals(vec, oven::counting(<span class="cpp_number_literal">3</span>, <span class="cpp_number_literal">10</span>)) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/copy_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">Seq</span> <span class="pre">seq</span> <span class="pre">=</span> <span class="pre">rng|copied;</span></tt> <a class="footnote-reference" href="#id10" id="id9" name="id9">[3]</a></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">Seq</span> <span class="pre">seq</span> <span class="pre">=</span> <span class="pre">boost::copy_range&lt;Seq&gt;(rng);</span></tt> is a valid expression.</li>
<li>Effect: <tt class="docutils literal"><span class="pre">Seq</span> <span class="pre">seq</span> <span class="pre">=</span> <span class="pre">boost::copy_range&lt;Seq&gt;(rng);</span></tt></li>
</ul>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9" name="id10">[3]</a></td><td><tt class="docutils literal"><span class="pre">Seq</span> <span class="pre">seq(rng|copied);</span></tt> is not a valid expression.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id61" id="distance" name="distance">5.6&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">distance</span></tt></a></h2>
<p>The upcoming <a class="reference" href="http://www.boost.org/libs/range/">Boost.Range</a> will replace <tt class="docutils literal"><span class="pre">boost::size</span></tt> by <tt class="docutils literal"><span class="pre">boost::distance</span></tt>.
<tt class="docutils literal"><span class="pre">oven::distance</span></tt> that is the same as <tt class="docutils literal"><span class="pre">boost::distance</span></tt> makes your code portable:</p>
<pre class="cpp_source">
std::string str(<span class="cpp_string_literal">&quot;012345&quot;</span>);
BOOST_CHECK( oven::distance(str) == <span class="cpp_number_literal">6 </span>);</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/distance.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">distance(rng)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">std::distance(boost::begin(rng),boost::end(rng))</span></tt> is a valid expression.</li>
<li>Returns: <tt class="docutils literal"><span class="pre">std::distance(boost::begin(rng),boost::end(rng))</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id62" id="equals" name="equals">5.7&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">equals</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">equals</span></tt> is the range-based <tt class="docutils literal"><span class="pre">std::equal</span></tt> that takes two ranges as the arguments:</p>
<pre class="cpp_source">
std::string str(<span class="cpp_string_literal">&quot;hello, equals&quot;</span>);
std::vector&lt;<span class="cpp_keyword">char</span>&gt; vec = str|copied;
BOOST_CHECK( oven::equals(str, vec) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/equals.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">equals(rng1,rng2)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">equal(rng1,boost::begin(rng2))</span></tt> is a valid expression.</li>
<li>Returns: <tt class="docutils literal"><span class="pre">true</span></tt> if and only if the <tt class="docutils literal"><span class="pre">oven::equal(rng1,boost::begin(rng2))</span></tt> and <tt class="docutils literal"><span class="pre">boost::size(rng1)</span> <span class="pre">==</span> <span class="pre">boost::size(rng2)</span></tt> returns <tt class="docutils literal"><span class="pre">true</span></tt>. <a class="footnote-reference" href="#id12" id="id11" name="id11">[4]</a></li>
</ul>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11" name="id12">[4]</a></td><td>The size of two ranges too is checked.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id63" id="front-back" name="front-back">5.8&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">front/back</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/front_back.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">front(rng)</span></tt> and <tt class="docutils literal"><span class="pre">back(biRng)</span></tt>.</li>
<li>Precondition: <tt class="docutils literal"><span class="pre">boost::range_value</span></tt> of <tt class="docutils literal"><span class="pre">rng</span></tt> is <tt class="docutils literal"><span class="pre">CopyConstructible</span></tt>.</li>
<li>Returns:  <tt class="docutils literal"><span class="pre">V(*boost::begin(rng))</span></tt> and <tt class="docutils literal"><span class="pre">V(*--boost::end(biRng))</span></tt> respectively, where <tt class="docutils literal"><span class="pre">V</span></tt> is <tt class="docutils literal"><span class="pre">boost::range_value</span></tt> of <tt class="docutils literal"><span class="pre">rng</span></tt>. <a class="footnote-reference" href="#id14" id="id13" name="id13">[5]</a></li>
</ul>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13" name="id14">[5]</a></td><td>They don't return references because of 24.1/9.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id64" id="utilities" name="utilities">6&nbsp;&nbsp;&nbsp;Utilities</a></h1>
<p>Some helper function objects are given to fill the gap between Oven and other libraries.</p>
<div class="section">
<h2><a class="toc-backref" href="#id65" id="innumerable" name="innumerable">6.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">innumerable</span></tt></a></h2>
<p>As discribed below, the function object <a class="reference" href="#generation">generation</a> needs is slightly different from
the Generator concept defined by the Standard.
<tt class="docutils literal"><span class="pre">innumerable</span></tt> turns the Generator function object into the Standard conforming one,
which creates an infinite range, working with <a class="reference" href="#generation">generation</a>.</p>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/generation.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">innumerable(rfun)</span></tt></li>
<li>Returns: A <a class="reference" href="#generation">generation</a> conforming function object.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id66" id="regular" name="regular">6.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">regular</span></tt></a></h2>
<p>Boost.Lambda functors are neither <tt class="docutils literal"><span class="pre">DefaultConstructible</span></tt> nor <tt class="docutils literal"><span class="pre">CopyAssignable</span></tt>.
An iterator holding such a functor cannot conform to even <tt class="docutils literal"><span class="pre">InputIterator</span></tt>.
So that, <tt class="docutils literal"><span class="pre">regular</span></tt> converts it to comfortable one for iterators. <a class="footnote-reference" href="#id16" id="id15" name="id15">[6]</a></p>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/regular.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">regular(lambdaFunctor)</span></tt></li>
<li>Returns: A <tt class="docutils literal"><span class="pre">rfun</span></tt> which is <tt class="docutils literal"><span class="pre">DefaultConstructible</span></tt> and <tt class="docutils literal"><span class="pre">CopyAssignable</span></tt>.</li>
</ul>
<p>In principle, call <tt class="docutils literal"><span class="pre">regular</span></tt> before a lambda functor is passed to <a class="reference" href="#range-adaptors">Range Adaptors</a>.</p>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15" name="id16">[6]</a></td><td><tt class="docutils literal"><span class="pre">regular</span></tt> incidentally converts the functor into the one which can take non-const rvalues.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id67" id="shared-regular" name="shared-regular">6.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">shared_regular</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">shared_regular</span></tt> converts a noncopyable function object type to copyable one.</p>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/regular.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">shared_regular(p)</span></tt>.</li>
<li>Precondition: <tt class="docutils literal"><span class="pre">boost::shared_ptr</span></tt> is constructible from <tt class="docutils literal"><span class="pre">p</span></tt>.</li>
<li>Returns: A <tt class="docutils literal"><span class="pre">rfun</span></tt> which is <tt class="docutils literal"><span class="pre">DefaultConstructible</span></tt> and <tt class="docutils literal"><span class="pre">CopyAssignable</span></tt>.</li>
</ul>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id68" id="ranges" name="ranges">7&nbsp;&nbsp;&nbsp;Ranges</a></h1>
<p>Oven provides some predefined range types.
<tt class="docutils literal"><span class="pre">&lt;pstade/oven/ranges.hpp&gt;</span></tt> includes every range header unless otherwise specified.</p>
<div class="section">
<h2><a class="toc-backref" href="#id69" id="any-range" name="any-range">7.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">any_range</span></tt></a></h2>
<p>Oven supports <tt class="docutils literal"><span class="pre">boost::result_of</span></tt>, but it is sometimes cumbersome to get the type of
the adapted range. <tt class="docutils literal"><span class="pre">any_range</span></tt> behaves as the type erasure of ranges:</p>
<pre class="cpp_source">
std::string rng(<span class="cpp_string_literal">&quot;hello! any_range!&quot;</span>);
any_range&lt;<span class="cpp_keyword">char </span><span class="cpp_keyword">const</span>&amp;&gt; any_ =
    rng|transformed(to_upper)|const_lvalues|filtered(regular(lambda::_1 != <span class="cpp_string_literal">'!'</span>));

BOOST_CHECK( oven::equals(any_, std::string(<span class="cpp_string_literal">&quot;HELLO ANY_RANGE&quot;</span>)) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/any_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">any_range&lt;R,T&gt;</span> <span class="pre">any_;</span></tt>, <tt class="docutils literal"><span class="pre">any_range&lt;R,T&gt;</span> <span class="pre">any_(rng);</span></tt> and <tt class="docutils literal"><span class="pre">any_range&lt;R,T&gt;</span> <span class="pre">any_</span> <span class="pre">=</span> <span class="pre">rng;</span></tt>
, where the iterators of <tt class="docutils literal"><span class="pre">any_</span></tt> are <tt class="docutils literal"><span class="pre">Interoperatable</span></tt> if and only if <tt class="docutils literal"><span class="pre">rng</span></tt>s are the same type.</li>
<li>Precondition: <tt class="docutils literal"><span class="pre">boost::range_reference</span></tt> of <tt class="docutils literal"><span class="pre">rng</span></tt> is convertible to <tt class="docutils literal"><span class="pre">R</span></tt> without creating rvalue.
<tt class="docutils literal"><span class="pre">T</span></tt> is a <tt class="docutils literal"><span class="pre">TraversalTag</span></tt>.</li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <a class="reference" href="http://thbecker.net/free_software_utilities/type_erasure_for_cpp_iterators/start_page.html">any_iterator</a></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id70" id="array-range" name="array-range">7.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">array_range</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">array_range</span></tt> is a non-Copyable <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#random_access_range">Random Access Range</a> which delivers
a range presentation of dynamically allocated arrays:</p>
<pre class="cpp_source">
std::string str(<span class="cpp_string_literal">&quot;hello, array_range!&quot;</span>);
boost::array&lt;<span class="cpp_keyword">char</span>, <span class="cpp_number_literal">19</span>&gt; sarr;
oven::copy(str, sarr|begin);
oven::array_range&lt;<span class="cpp_keyword">char</span>&gt; darr(<span class="cpp_number_literal">19</span>);
oven::copy(str, darr|begin);

BOOST_CHECK( oven::equals(sarr, darr) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/array_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">array_range&lt;T&gt;</span> <span class="pre">rng(sz);</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">new</span> <span class="pre">T[sz];</span></tt> is a valid expression.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id71" id="directory-range" name="directory-range">7.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">directory_range</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">directory_range</span></tt> is a <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#single_pass_range">Single Pass Range</a> which accesses the contents of a directory:</p>
<pre class="cpp_source">
BOOST_FOREACH (
    filesystem::path <span class="cpp_keyword">const</span>&amp; pt,
    directory_range(filesystem::current_path()))
{
    std::cout &lt;&lt; pt.leaf() &lt;&lt; std::endl;
}</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/directory_range.hpp&gt;</span></tt>; not included by <tt class="docutils literal"><span class="pre">&lt;pstade/oven/ranges.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">directory_range</span> <span class="pre">rng(p);</span></tt> and <tt class="docutils literal"><span class="pre">wdirectory_range</span> <span class="pre">wrng(wp);</span></tt></li>
<li>Precondition: The type of <tt class="docutils literal"><span class="pre">p</span></tt> is <tt class="docutils literal"><span class="pre">boost::filesystem::path</span></tt> and
the type of <tt class="docutils literal"><span class="pre">wp</span></tt> is <tt class="docutils literal"><span class="pre">boost::filesystem::wpath</span></tt>.</li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <a class="reference" href="http://www.boost.org/libs/filesystem/doc/operations.htm#directory_iterator">directory_iterator</a></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id72" id="empty-range" name="empty-range">7.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">empty_range</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">empty_range</span></tt> is a <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#random_access_range">Random Access Range</a> which is always empty:</p>
<pre class="cpp_source">
BOOST_CHECK( boost::empty(empty_range&lt;<span class="cpp_keyword">int</span>&gt;()) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/empty_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">empty_range&lt;T&gt;</span> <span class="pre">rng;</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id73" id="file-range" name="file-range">7.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">file_range</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">file_range</span></tt> is a constant <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#random_access_range">Random Access Range</a> for files:</p>
<pre class="cpp_source">
std::vector&lt;<span class="cpp_keyword">char</span>&gt; vec;
oven::copy(file_range&lt;<span class="cpp_keyword">char</span>&gt;(<span class="cpp_string_literal">&quot;data.txt&quot;</span>), std::back_inserter(vec));</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/file_range.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">file_range&lt;C&gt;</span> <span class="pre">rng;</span></tt> and <tt class="docutils literal"><span class="pre">rng.is_open();</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">boost::spirit::file_iterator&lt;C&gt;</span></tt> is a valid expression.</li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <a class="reference" href="http://www.boost.org/libs/spirit/doc/file_iterator.html">file_iterator</a></li>
</ul>
<p>The member <tt class="docutils literal"><span class="pre">is_open()</span></tt> returns <tt class="docutils literal"><span class="pre">true</span></tt> if and only if the file opening is succeeded.
If <tt class="docutils literal"><span class="pre">is_open()</span></tt> is not <tt class="docutils literal"><span class="pre">true</span></tt>, the range is empty.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id74" id="range-makers" name="range-makers">8&nbsp;&nbsp;&nbsp;Range Makers</a></h1>
<p>Oven provides some predefined functions which produce a range.
All the range returned from the following makers are <tt class="docutils literal"><span class="pre">CopyConstructible</span></tt> and <tt class="docutils literal"><span class="pre">Inheritable</span></tt>.
<tt class="docutils literal"><span class="pre">&lt;pstade/oven/functions.hpp&gt;</span></tt> includes every maker header unless otherwise specified.</p>
<div class="section">
<h2><a class="toc-backref" href="#id75" id="as-array" name="as-array">8.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">as_array</span></tt></a></h2>
<p>The current Boost.Range regards char array as literal, which <tt class="docutils literal"><span class="pre">as_array</span></tt> works around.</p>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/as_array.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">as_array(arr)</span></tt> and <tt class="docutils literal"><span class="pre">arr|as_array</span></tt></li>
<li>Effect: same as <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2059.html#as-array">TR2 as_array</a></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id76" id="as-c-str" name="as-c-str">8.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">as_c_str</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">as_c_str</span></tt> makes a <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#random_access_range">Random Access Range</a> from null-terminated c-style string:</p>
<pre class="cpp_source">
{
    <span class="cpp_keyword">wchar_t </span><span class="cpp_keyword">const </span>*psz = L<span class="cpp_string_literal">&quot;hello range&quot;</span>;
    BOOST_CHECK( oven::equals(psz|as_c_str, std::wstring(L<span class="cpp_string_literal">&quot;hello range&quot;</span>)) );
}
{
    std::string src(<span class="cpp_string_literal">&quot;hello range&quot;</span>);
    BOOST_CHECK( oven::equals(src.c_str()|as_c_str, src) );
}</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/as_c_str.hpp&gt;</span></tt></li>
<li>Valid expression2: <tt class="docutils literal"><span class="pre">as_c_str(x)</span></tt> and <tt class="docutils literal"><span class="pre">x|as_c_str</span></tt>.</li>
<li>Returns: If  <tt class="docutils literal"><span class="pre">x</span></tt> is convertible to a char pointer, <tt class="docutils literal"><span class="pre">[x,x+strlen(psz))</span></tt>; otherwise, <tt class="docutils literal"><span class="pre">[boost::begin(x),oven::find(x,0))</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id77" id="as-literal" name="as-literal">8.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">as_literal</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">as_literal</span></tt> makes a <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#random_access_range">Random Access Range</a> from character array.
<tt class="docutils literal"><span class="pre">as_literal</span></tt> doesn't support any pointer type but array type. So it is safe and fast. Compare it with <tt class="docutils literal"><span class="pre">as_c_str</span></tt>:</p>
<pre class="cpp_source">
{
    BOOST_CHECK( oven::equals(<span class="cpp_string_literal">&quot;hello range&quot;</span>|as_literal, std::string(<span class="cpp_string_literal">&quot;hello range&quot;</span>)) );
}
{
    BOOST_CHECK( oven::equals(
        <span class="cpp_string_literal">&quot;hello\0range&quot;</span>|as_c_str,
        std::string(<span class="cpp_string_literal">&quot;hello&quot;</span>)
    ) );
    BOOST_CHECK( oven::equals(
        <span class="cpp_string_literal">&quot;hello\0range&quot;</span>|as_literal,
        std::string(<span class="cpp_string_literal">&quot;hello&quot;</span>)|jointed(<span class="cpp_string_literal">'\0'</span>|as_single)|jointed(std::string(<span class="cpp_string_literal">&quot;range&quot;</span>))
    ) );
}</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/as_literal.hpp&gt;</span></tt></li>
<li>Valid expression1: <tt class="docutils literal"><span class="pre">as_literal(x)</span></tt> and <tt class="docutils literal"><span class="pre">x|as_literal</span></tt></li>
<li>Returns:If <tt class="docutils literal"><span class="pre">x</span></tt> is an array,  <tt class="docutils literal"><span class="pre">[&amp;x[0],&amp;x[0]+sz-1)</span></tt> where <tt class="docutils literal"><span class="pre">sz</span></tt> is the size of <tt class="docutils literal"><span class="pre">arr</span></tt>; otherwise, <tt class="docutils literal"><span class="pre">x</span></tt> as is. <a class="footnote-reference" href="#id22" id="id21" name="id21">[7]</a></li>
</ul>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21" name="id22">[7]</a></td><td><tt class="docutils literal"><span class="pre">as_literal</span></tt> doesn't use <tt class="docutils literal"><span class="pre">strlen</span></tt>. <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2059.html#as-literal">TR2 as_literal</a> does.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id78" id="as-single" name="as-single">8.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">as_single</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">as_single</span></tt> makes a <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#random_access_range">Random Access Range</a> which delivers a range presentation of one object:</p>
<pre class="cpp_source">
BOOST_CHECK( oven::equals(<span class="cpp_string_literal">'a'</span>|as_single, std::string(<span class="cpp_string_literal">&quot;a&quot;</span>)) );
</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/as_single.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">as_single(v)</span></tt> and <tt class="docutils literal"><span class="pre">v|as_single</span></tt></li>
<li>Returns: A range which behaves as if it were <tt class="docutils literal"><span class="pre">[&amp;v,&amp;v+1)</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id79" id="as-shared-single" name="as-shared-single">8.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">as_shared_single</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/as_single.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">as_shared_single(p)</span></tt> and <tt class="docutils literal"><span class="pre">p|as_shared_single</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">boost::shared_ptr</span></tt> is constructible from <tt class="docutils literal"><span class="pre">p</span></tt>.</li>
<li>Returns: A range which behaves as if it were <tt class="docutils literal"><span class="pre">[&amp;*p,&amp;*p+1)</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id80" id="counting" name="counting">8.6&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">counting</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">counting</span></tt> introduces the replacement of <tt class="docutils literal"><span class="pre">for</span></tt> loop:</p>
<pre class="cpp_source">
<span class="cpp_keyword">int </span>ans[] = { <span class="cpp_number_literal">2</span>, <span class="cpp_number_literal">3</span>, <span class="cpp_number_literal">4</span>, <span class="cpp_number_literal">5</span>, <span class="cpp_number_literal">6 </span>};
BOOST_CHECK( oven::equal(counting(<span class="cpp_number_literal">2</span>, <span class="cpp_number_literal">7</span>), ans) );

std::vector&lt;<span class="cpp_keyword">int</span>&gt; vec;
BOOST_FOREACH (<span class="cpp_keyword">int </span>i, counting(<span class="cpp_number_literal">0</span>, <span class="cpp_number_literal">5</span>)) {
    vec.push_back(i);
}</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/counting.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">counting(n,</span> <span class="pre">m)</span></tt>, where <tt class="docutils literal"><span class="pre">n</span></tt> and <tt class="docutils literal"><span class="pre">m</span></tt> is <tt class="docutils literal"><span class="pre">Incrementable</span></tt>.</li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <a class="reference" href="http://www.boost.org/libs/iterator/doc/counting_iterator.html">counting_iterator</a></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id81" id="counting-from" name="counting-from">8.7&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">counting_from</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/counting.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">counting_from(n)</span></tt>, where <tt class="docutils literal"><span class="pre">n</span></tt> is <tt class="docutils literal"><span class="pre">Incrementable</span></tt>.</li>
<li>Returns: A range which behaves as if <tt class="docutils literal"><span class="pre">counting(n,std::numeric_limits&lt;N&gt;::max())</span></tt>, where <tt class="docutils literal"><span class="pre">N</span></tt> is the type of <tt class="docutils literal"><span class="pre">n</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id82" id="generation" name="generation">8.8&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">generation</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">generation</span></tt> returns a range whose iterators were originally written as <a class="reference" href="http://www.boost.org/libs/utility/generator_iterator.htm">generator_iterator</a>:</p>
<pre class="cpp_source">
<span class="cpp_keyword">struct </span>rand_generator
{
    <span class="cpp_keyword">typedef </span>boost::optional&lt;<span class="cpp_keyword">long</span>&gt; result_type;

    result_type <span class="cpp_keyword">operator</span>()()
    {
        <span class="cpp_keyword">long </span>result = std::rand();
        <span class="cpp_keyword">if </span>(result % <span class="cpp_number_literal">3 </span>== <span class="cpp_number_literal">0</span>)
            <span class="cpp_keyword">return </span>result_type(); <span class="cpp_comment">// range is end.

        </span><span class="cpp_keyword">return </span>result;
    }
};

<span class="cpp_keyword">void </span>test()
{
    rand_generator X;
    BOOST_FOREACH (<span class="cpp_keyword">long </span>x, oven::generation(X)) {
        std::cout &lt;&lt; x &lt;&lt; std::endl;
    }
}</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/generation.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">generation(rfun)</span></tt></li>
<li>Precondition:<tt class="docutils literal"><span class="pre">rfun</span></tt> call returns initialized <tt class="docutils literal"><span class="pre">boost::optional</span></tt> if range is not end; Otherwise, returns uninitialized one.</li>
<li>Returns: A <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#single_pass_range">Single Pass Range</a> whose values are the results of invoking <tt class="docutils literal"><span class="pre">rfun</span></tt>.</li>
</ul>
<p>If you have a Standard conforming Generator, you can convert it to <tt class="docutils literal"><span class="pre">generation</span></tt> conforming one by using <a class="reference" href="#innumerable">innumerable</a>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id83" id="indexing" name="indexing">8.9&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">indexing</span></tt></a></h2>
<p><cite>Pending...</cite></p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id84" id="iteration" name="iteration">8.10&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">iteration</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">iteration</span></tt> makes an infinite range where the first item is calculated by applying
the function on the first argument, the second item by applying the function on the previous result and so on:</p>
<pre class="cpp_source">
<span class="cpp_keyword">int </span>answer[] = { <span class="cpp_number_literal">1</span>,<span class="cpp_number_literal">2</span>,<span class="cpp_number_literal">4</span>,<span class="cpp_number_literal">8</span>,<span class="cpp_number_literal">16 </span>};
BOOST_CHECK( oven::equals(answer,
    oven::iteration(<span class="cpp_number_literal">1</span>, regular(lambda::_1 * <span class="cpp_number_literal">2</span>))|oven::taken(<span class="cpp_number_literal">5</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/iteration.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">iteration(x,fun)</span></tt></li>
<li>Returns: An infinite <a class="footnote-reference" href="#id27" id="id26" name="id26">[8]</a> <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#single_pass_range">Single Pass Range</a> of repeated applications of <tt class="docutils literal"><span class="pre">fun</span></tt> to <tt class="docutils literal"><span class="pre">x</span></tt>.</li>
</ul>
<table class="docutils footnote" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id26" name="id27">[8]</a></td><td>Strictly speaking, the <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#single_pass_range">Single Pass Range</a> concept doesn't allow an infinite range. So assume here the end iterator is reachable from the begin iterator in the googolplex number of increments.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id85" id="recursion" name="recursion">8.11&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">recursion</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">recursion</span></tt>, collaborating with <a class="reference" href="#any-range">any_range</a>, creates a recursive <a class="footnote-reference" href="#id29" id="id28" name="id28">[9]</a> range:</p>
<pre class="cpp_source">
<span class="cpp_keyword">typedef </span>any_range&lt;<span class="cpp_keyword">int </span><span class="cpp_keyword">const</span>&amp;, boost::forward_traversal_tag&gt; range_t;
range_t fibs;
memo_table tb;
<span class="cpp_keyword">int </span><span class="cpp_keyword">const </span>start[] = { <span class="cpp_number_literal">1</span>, <span class="cpp_number_literal">1 </span>};
fibs =
    start
        | transformed(pstade::as_value)
        | jointed(
            boost::make_tuple(recursion(fibs), recursion(fibs)|dropped(<span class="cpp_number_literal">1</span>))
                | zipped_with(regular(lambda::_1 + lambda::_2))
            )
        | memoized(tb)
;

std::cout &lt;&lt; (fibs|taken(howMany));</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/recursion.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">recursion(fwdRng)</span></tt>, where <tt class="docutils literal"><span class="pre">fwdRng</span></tt> is an <tt class="docutils literal"><span class="pre">any_range</span></tt> object.</li>
<li>Returns: An infinite range up to  <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#bidirectional_range">Bidirectional Range</a>.</li>
</ul>
<table class="docutils footnote" frame="void" id="id29" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id28" name="id29">[9]</a></td><td>In a recursive range, <tt class="docutils literal"><span class="pre">memoized</span></tt> must take a named <tt class="docutils literal"><span class="pre">memo_table</span></tt> object. A recursive range tends to be inefficient without memoization.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id86" id="repeated" name="repeated">8.12&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">repeated</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">repeated</span></tt> makes a <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#random_access_range">Random Access Range</a> where all values are the first argument:</p>
<pre class="cpp_source">
BOOST_CHECK( oven::equals(
    <span class="cpp_string_literal">'A'</span>|repeated(<span class="cpp_number_literal">6</span>),
    std::string(<span class="cpp_string_literal">&quot;AAAAAA&quot;</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/repeated.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">v|repeated(c)</span></tt> and <tt class="docutils literal"><span class="pre">make_repeated(v,c)</span></tt></li>
<li>Returns: A range which behaves as if it were <tt class="docutils literal"><span class="pre">as_single(v)|cycled(c)</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id87" id="stream-input" name="stream-input">8.13&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">stream_input</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">stream_input</span></tt> makes a <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#single_pass_range">Single Pass Range</a> from <tt class="docutils literal"><span class="pre">std::cout</span></tt> etc:</p>
<pre class="cpp_source">
std::string src(<span class="cpp_string_literal">&quot;hello,stream_input!&quot;</span>);

std::stringstream ss;
ss &lt;&lt; src;

std::string result;
oven::copy(oven::stream_input&lt;<span class="cpp_keyword">char</span>&gt;(ss), std::back_inserter(result));

BOOST_CHECK( oven::equals(result, src) );</pre>

<ul class="simple">
<li>Valid expression: <tt class="docutils literal"><span class="pre">oven::stream_input&lt;V&gt;(stm)</span></tt></li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <a class="reference" href="http://www.sgi.com/tech/stl/istream_iterator.html">istream_iterator</a></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id88" id="streambuf-input" name="streambuf-input">8.14&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">streambuf_input</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/stream_input.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">oven::streambuf_input(stm)</span></tt></li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <tt class="docutils literal"><span class="pre">istreambuf_iterator</span></tt></li>
</ul>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id89" id="range-adaptors" name="range-adaptors">9&nbsp;&nbsp;&nbsp;Range Adaptors</a></h1>
<p>A Range Adaptor delivers an altered presentation of one or more underlying ranges.
Range Adaptors are lazy, meaning that their elements are only computed on demand.
The underlying ranges are not modified.
Additional information is available at <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.
<tt class="docutils literal"><span class="pre">&lt;pstade/oven/adaptors.hpp&gt;</span></tt> includes all the following Range Adaptors unless otherwise specified.</p>
<p>Note that all the range returned from the following adaptors are <tt class="docutils literal"><span class="pre">CopyConstructible</span></tt> and <tt class="docutils literal"><span class="pre">Inheritable</span></tt>.
Also, if <tt class="docutils literal"><span class="pre">a0|xxx(a1,..,aN)</span></tt> is a valid expression, then  <tt class="docutils literal"><span class="pre">make_xxx(a0,..,aN)</span></tt> too is a valid expression
which has the same effect.</p>
<div class="section">
<h2><a class="toc-backref" href="#id90" id="adjacent-filtered" name="adjacent-filtered">9.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">adjacent_filtered</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/adjacent_filtered.hpp&gt;</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id91" id="adjacent-transformed" name="adjacent-transformed">9.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">adjacent_transformed</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/adjacent_transformed.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">fwdRng|adjacent_transformed(rfun)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">boost::empty(fwdRng)</span> <span class="pre">==</span> <span class="pre">false</span></tt></li>
<li>Returns: A range where adjacent pairs of <tt class="docutils literal"><span class="pre">fwdRng</span></tt> are transformed by using <tt class="docutils literal"><span class="pre">rfun</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id92" id="advanced" name="advanced">9.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">advanced</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/advanced.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">fwdRng|advanced(d1,d2)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">fwdRng</span></tt> must be a <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#bidirectional_range">Bidirectional Range</a> if either <tt class="docutils literal"><span class="pre">d1</span></tt> or <tt class="docutils literal"><span class="pre">d2</span></tt> is negative.</li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::next(boost::begin(fwdRng),d1),boost::next(boost::end(fwdRng),d2))</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id93" id="always" name="always">9.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">always</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">always</span></tt> returns a range which does not change as the base range vary:</p>
<pre class="cpp_source">
BOOST_CHECK( oven::equals(
    std::string(<span class="cpp_string_literal">&quot;labor&quot;</span>)
        | jointed(std::string(<span class="cpp_string_literal">&quot;will be&quot;</span>))
        | always(<span class="cpp_string_literal">&quot;lost&quot;</span>),
    std::string(<span class="cpp_string_literal">&quot;lost&quot;</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/always.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">unusedRng|always(rng)</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::begin(rng),boost::end(rng))</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id94" id="appended" name="appended">9.5&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">appended</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">appended</span></tt> returns a range which is appended with its argument:</p>
<pre class="cpp_source">
std::string <span class="cpp_keyword">const </span>str(<span class="cpp_string_literal">&quot;hello, appen&quot;</span>);

BOOST_CHECK( oven::equals(
    str|appended(<span class="cpp_string_literal">'d'</span>)|appended(<span class="cpp_string_literal">'e'</span>)|appended(<span class="cpp_string_literal">'d'</span>)|appended(<span class="cpp_string_literal">'!'</span>),
    std::string(<span class="cpp_string_literal">&quot;hello, appended!&quot;</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/appended.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|appended(v)</span></tt></li>
<li>Returns: A range which behaves as if it were <tt class="docutils literal"><span class="pre">rng|jointed(as_single(v))</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id95" id="applied" name="applied">9.6&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">applied</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">applied</span></tt>, taking a <a class="reference" href="http://www.sgi.com/tech/stl/functors.html">Function Object</a> which represents an algorithm, creates the range adaptor:</p>
<pre class="cpp_source">
<span class="cpp_keyword">namespace </span>lambda = boost::lambda;
std::string src(<span class="cpp_string_literal">&quot;abcdefghijk&quot;</span>);
std::string s1(<span class="cpp_string_literal">&quot;efg&quot;</span>);
BOOST_CHECK((
    oven::equals(
        std::string(<span class="cpp_string_literal">&quot;efghijk&quot;</span>),
        src|applied(lambda::bind(oven::search, lambda::_1, s1), oven::end)
    )
));</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/applied.hpp&gt;</span></tt></li>
<li>Valid expression1: <tt class="docutils literal"><span class="pre">rng|applied(f1,f2)</span></tt>, where <tt class="docutils literal"><span class="pre">f1(rng)</span></tt> and <tt class="docutils literal"><span class="pre">f2(rng)</span></tt> must return iterators that are convertible to <tt class="docutils literal"><span class="pre">rng</span></tt>'s.</li>
<li>Valid expression2: <tt class="docutils literal"><span class="pre">rng|applied(f)</span></tt>, where <tt class="docutils literal"><span class="pre">f(rng)</span></tt> must return a range whose iterators are convertible to  <tt class="docutils literal"><span class="pre">rng</span></tt>'s.</li>
<li>Returns: <tt class="docutils literal"><span class="pre">[f1(rng),f2(rng))</span></tt>, or <tt class="docutils literal"><span class="pre">[boost::begin(r),boost::end(r))</span></tt> where <tt class="docutils literal"><span class="pre">r</span> <span class="pre">=</span> <span class="pre">f(rng)</span></tt>, respectively.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id96" id="broken-into" name="broken-into">9.7&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">broken_into</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">broken_into</span></tt> is the adaptor version of <tt class="docutils literal"><span class="pre">boost::tokenizer</span></tt>:</p>
<pre class="cpp_source">
<span class="cpp_keyword">int </span><span class="cpp_keyword">const </span>offsets[] = { <span class="cpp_number_literal">2</span>,<span class="cpp_number_literal">2</span>,<span class="cpp_number_literal">4 </span>};
std::string src(<span class="cpp_string_literal">&quot;12252001&quot;</span>);
std::vector&lt;std::string&gt; ans; {
    ans.push_back(<span class="cpp_string_literal">&quot;12&quot;</span>);
    ans.push_back(<span class="cpp_string_literal">&quot;25&quot;</span>);
    ans.push_back(<span class="cpp_string_literal">&quot;2001&quot;</span>);
}

BOOST_CHECK( oven::equals(
    ans,
    src|broken_into&lt;std::string&gt;(boost::offset_separator(offsets, offsets+<span class="cpp_number_literal">3</span>))
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/broken_into.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|broken_into&lt;t&gt;(f)</span></tt>, where <tt class="docutils literal"><span class="pre">f</span></tt> is a <tt class="docutils literal"><span class="pre">TokenizerFunction</span></tt>.</li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <tt class="docutils literal"><span class="pre">boost::token_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id97" id="checked" name="checked">9.8&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">checked</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">checked</span></tt> adds the bounds checking ability to the base range:</p>
<pre class="cpp_source">
std::string in(<span class="cpp_string_literal">&quot;012345&quot;</span>);
std::string out(<span class="cpp_string_literal">&quot;01234&quot;</span>);

<span class="cpp_keyword">try </span>{
    oven::copy(in, boost::begin(out|checked));
}
<span class="cpp_keyword">catch </span>(check_error <span class="cpp_keyword">const</span>&amp; ) {
    <span class="cpp_keyword">return</span>;
}

BOOST_CHECK(<span class="cpp_keyword">false</span>);</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/checked.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|checked</span></tt></li>
<li>Effect: Throws <tt class="docutils literal"><span class="pre">check_error</span></tt> derived from <tt class="docutils literal"><span class="pre">std::range_error</span></tt> if iterators go out of <tt class="docutils literal"><span class="pre">rng</span></tt>.</li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::begin(rng),boost::end(rng))</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id98" id="cleared" name="cleared">9.9&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">cleared</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">cleared</span></tt> returns a range which is always empty:</p>
<pre class="cpp_source">
BOOST_CHECK( boost::empty(
    std::string(<span class="cpp_string_literal">&quot;labor&quot;</span>)
        | jointed(std::string(<span class="cpp_string_literal">&quot;lost&quot;</span>))
        | cleared
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/cleared.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|cleared</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::end(rng),boost::end(rng))</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id99" id="concatenated" name="concatenated">9.10&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">concatenated</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">concatenated</span></tt> accepts a range whose <tt class="docutils literal"><span class="pre">value_type</span></tt> is a range and concatenates them:</p>
<pre class="cpp_source">
std::string input(<span class="cpp_string_literal">&quot;This is his face&quot;</span>);
boost::regex re(<span class="cpp_string_literal">&quot;\\w+&quot;</span>);
BOOST_CHECK( oven::equals(
    input|tokenized(re)|concatenated,
    std::string(<span class="cpp_string_literal">&quot;Thisishisface&quot;</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/concatenated.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rngs|concatenated</span></tt></li>
<li>Specification: <tt class="docutils literal"><span class="pre">SegmentIterator</span></tt> is an iterator of <tt class="docutils literal"><span class="pre">rngs</span></tt>, and <tt class="docutils literal"><span class="pre">LocalIterator</span></tt> is an iterator of the range which the dereference of <tt class="docutils literal"><span class="pre">SegmentIterator</span></tt> returns.</li>
<li>Precondition: The <tt class="docutils literal"><span class="pre">LocalIterator</span></tt> must be valid after copying of <tt class="docutils literal"><span class="pre">SegmentIterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id100" id="constants" name="constants">9.11&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">constants</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/constants.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|constants</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::end(rng),boost::end(rng))</span></tt> whose iterators are constant.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id101" id="const-lvalues" name="const-lvalues">9.12&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">const_lvalues</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">const_lvalues</span></tt> turns the associated <tt class="docutils literal"><span class="pre">reference</span></tt> type of the base range into reference type,
which makes iterators of <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#forward_range">Forward Range</a> conform to <tt class="docutils literal"><span class="pre">ForwardIterator</span></tt>.
Thus, STL that doesn't know traversal concepts can choose effective algorithms.</p>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/const_lvalues.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|const_lvalues</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">value_type</span></tt> of <tt class="docutils literal"><span class="pre">rng</span></tt> is <tt class="docutils literal"><span class="pre">CopyConstructible</span></tt>, <tt class="docutils literal"><span class="pre">Assignable</span></tt> and <tt class="docutils literal"><span class="pre">DefaultConstructible</span></tt>.</li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::begin(rng),boost::end(rng))</span></tt> whose iterators are constant.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id102" id="copied-out" name="copied-out">9.13&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">copied_out</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">copied_out</span></tt> makes a side-effect that copies the base range to its argument:</p>
<pre class="cpp_source">
std::string src(<span class="cpp_string_literal">&quot;axaxaxbxbxbx&quot;</span>);
std::string snapshot;
std::string answer(<span class="cpp_string_literal">&quot;bbb&quot;</span>);

BOOST_CHECK( oven::equals(
    src
        | filtered(regular(lambda::_1 != <span class="cpp_string_literal">'x'</span>))
        | copied_out(std::back_inserter(snapshot))
        | filtered(regular(lambda::_1 != <span class="cpp_string_literal">'a'</span>)),
    answer
) );

BOOST_CHECK( snapshot == <span class="cpp_string_literal">&quot;aaabbb&quot;</span> );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/copied_out.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|copied_out(it)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">oven::copy(rng,it)</span></tt> is a valid expression.</li>
<li>Effect: <tt class="docutils literal"><span class="pre">oven::copy(rng,it)</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">rng</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id103" id="cycled" name="cycled">9.14&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">cycled</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">cycled</span></tt> creates a circular range from the base range:</p>
<pre class="cpp_source">
BOOST_CHECK( oven::equals(
    std::string(<span class="cpp_string_literal">&quot;xyz&quot;</span>)|cycled(<span class="cpp_number_literal">3</span>),
    std::string(<span class="cpp_string_literal">&quot;xyzxyzxyz&quot;</span>)
) );
</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/cycled.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|cycled(n)</span></tt></li>
<li>Returns: A constant range that repeats <tt class="docutils literal"><span class="pre">[boost::begin(rng),boost::end(rng))</span></tt> <tt class="docutils literal"><span class="pre">n</span></tt> times.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id104" id="delimited" name="delimited">9.15&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">delimited</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">delimited</span></tt> adds a delimiter to the base range:</p>
<pre class="cpp_source">
BOOST_CHECK( equals(
    std::string(<span class="cpp_string_literal">&quot;abcde&quot;</span>)|transformed(as_single)|
        delimited(<span class="cpp_string_literal">&quot;--&quot;</span>|as_literal)|dropped(<span class="cpp_number_literal">2</span>),
    std::string(<span class="cpp_string_literal">&quot;a--b--c--d--e&quot;</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/delimited.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rngs|delimited(delim)</span></tt>, where <tt class="docutils literal"><span class="pre">delim</span></tt> is a Range to specify the delimiter.</li>
<li>Returns: A range which behaves as if it were <tt class="docutils literal"><span class="pre">rngs|transformed(with)|concatenated</span></tt>, where <tt class="docutils literal"><span class="pre">with</span></tt> is a <a class="reference" href="http://www.sgi.com/tech/stl/functors.html">Function Object</a> which calls <tt class="docutils literal"><span class="pre">make_jointed</span></tt> to joint <tt class="docutils literal"><span class="pre">delim</span></tt>. <a class="footnote-reference" href="#id32" id="id31" name="id31">[10]</a></li>
</ul>
<table class="docutils footnote" frame="void" id="id32" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id31" name="id32">[10]</a></td><td><tt class="docutils literal"><span class="pre">delimited</span></tt> prepends the delimiter. <tt class="docutils literal"><span class="pre">dropped</span></tt> is useful to remove it.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id105" id="directed" name="directed">9.16&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">directed</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">directed</span></tt> returns a range whose values are iterators of the base range:</p>
<pre class="cpp_source">
std::string <span class="cpp_keyword">const </span>str(<span class="cpp_string_literal">&quot;gefadcb&quot;</span>);
std::string <span class="cpp_keyword">const </span>answer(<span class="cpp_string_literal">&quot;abcdefg&quot;</span>);

std::vector&lt;std::string::const_iterator&gt; iters;
oven::copy(str|directed, std::back_inserter(iters));
oven::sort( iters, boost::make_indirect_fun(::less_than()) );

BOOST_CHECK( oven::equals(iters|indirected, answer) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/directed.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|directed</span></tt></li>
<li>Returns: A range which behaves as if it were <tt class="docutils literal"><span class="pre">counting(boost::begin(rng),boost::end(rng))</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id106" id="dropped" name="dropped">9.17&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">dropped</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">dropped</span></tt> returns the suffix of the base range after the first <tt class="docutils literal"><span class="pre">n</span></tt> elements:</p>
<pre class="cpp_source">
BOOST_CHECK( oven::equals(
    std::string(<span class="cpp_string_literal">&quot;hello, dropped!&quot;</span>)|dropped(<span class="cpp_number_literal">7</span>),
    std::string(<span class="cpp_string_literal">&quot;dropped!&quot;</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/dropped.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|dropped(n)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">n</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::next(boost::begin(rng),std::min(n,distance(rng))),boost::end(rng))</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id107" id="dropped-while" name="dropped-while">9.18&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">dropped_while</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">dropped_while</span></tt> returns the remaining suffix of the base range of elements that satisfy <a class="reference" href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>:</p>
<pre class="cpp_source">
std::string src(<span class="cpp_string_literal">&quot;11111234516313!&quot;</span>);

BOOST_CHECK( oven::equals(
    src|dropped_while(lambda::_1 == <span class="cpp_string_literal">'1'</span>),
    std::string(<span class="cpp_string_literal">&quot;234516313!&quot;</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/dropped_while.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|dropped_while(pred)</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">[oven::find_if(rng,</span> <span class="pre">not_(pred)),boost::end(rng))</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id108" id="filtered" name="filtered">9.19&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">filtered</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">filtered</span></tt> returns a range which is filtered by using a <a class="reference" href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a> <a class="footnote-reference" href="#id34" id="id33" name="id33">[11]</a></p>
<pre class="cpp_source">
<span class="cpp_keyword">int </span>src[]    = { <span class="cpp_number_literal">2</span>,<span class="cpp_number_literal">5</span>,<span class="cpp_number_literal">2</span>,<span class="cpp_number_literal">6</span>,<span class="cpp_number_literal">1</span>,<span class="cpp_number_literal">3</span>,<span class="cpp_number_literal">2 </span>};
<span class="cpp_keyword">int </span>answer[] = { <span class="cpp_number_literal">0</span>,<span class="cpp_number_literal">5</span>,<span class="cpp_number_literal">0</span>,<span class="cpp_number_literal">6</span>,<span class="cpp_number_literal">1</span>,<span class="cpp_number_literal">3</span>,<span class="cpp_number_literal">0 </span>};

BOOST_FOREACH (<span class="cpp_keyword">int</span>&amp; i, src|filtered(regular(lambda::_1 == <span class="cpp_number_literal">2</span>))) {
    i = <span class="cpp_number_literal">0</span>;
}

BOOST_CHECK( oven::equals(answer, src) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/filtered.hpp&gt;</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
<table class="docutils footnote" frame="void" id="id34" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id33" name="id34">[11]</a></td><td>A non-assignable lambda functor makes <tt class="docutils literal"><span class="pre">filtered</span></tt> non-conforming, so it needs <a class="reference" href="#regular">regular</a> to be applied before it is passed.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id109" id="firsts" name="firsts">9.20&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">firsts</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/firsts.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|firsts</span></tt></li>
<li>Returns: A range which behaves as if it were <tt class="docutils literal"><span class="pre">rng|map_keys</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id110" id="got-at" name="got-at">9.21&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">got_at</span></tt></a></h2>
<p>Pending...</p>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/got_at.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|got_at&lt;N&gt;()</span></tt> or <tt class="docutils literal"><span class="pre">rng|got_at_c&lt;N&gt;()</span></tt>, where <tt class="docutils literal"><span class="pre">value_type</span></tt> of <tt class="docutils literal"><span class="pre">rng</span></tt> is a Fusion Sequence.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id111" id="identities" name="identities">9.22&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">identities</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">identities</span></tt> returns a range which is identical to the base range:</p>
<pre class="cpp_source">
BOOST_CHECK( oven::equals(
    std::string(<span class="cpp_string_literal">&quot;hello, identities!&quot;</span>)|identities,
    std::string(<span class="cpp_string_literal">&quot;hello, identities!&quot;</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/identities.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|identities</span></tt> and <tt class="docutils literal"><span class="pre">rng|identities(trv)</span></tt>, where <tt class="docutils literal"><span class="pre">trv</span></tt> is a traversal tag object.</li>
<li>Precondition: <tt class="docutils literal"><span class="pre">rng</span></tt>'s traversal tag is convertible to <tt class="docutils literal"><span class="pre">trv</span></tt>.</li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::begin(rng),boost::end(rng))</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id112" id="indirected" name="indirected">9.23&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">indirected</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">indirected</span></tt> adapts the base range by applying an extra dereference inside of <tt class="docutils literal"><span class="pre">operator*()</span></tt>:</p>
<pre class="cpp_source">
<span class="cpp_keyword">int </span>src[]    = { <span class="cpp_number_literal">1</span>,<span class="cpp_number_literal">2</span>,<span class="cpp_number_literal">0</span>,<span class="cpp_number_literal">4</span>,<span class="cpp_number_literal">5 </span>};
<span class="cpp_keyword">int </span>answer[] = { <span class="cpp_number_literal">1</span>,<span class="cpp_number_literal">2</span>,<span class="cpp_number_literal">3</span>,<span class="cpp_number_literal">4</span>,<span class="cpp_number_literal">5 </span>};
<span class="cpp_keyword">int </span>*ptrs[]  = {&amp;src[<span class="cpp_number_literal">0</span>],&amp;src[<span class="cpp_number_literal">1</span>],&amp;src[<span class="cpp_number_literal">2</span>],&amp;src[<span class="cpp_number_literal">3</span>],&amp;src[<span class="cpp_number_literal">4</span>]};

BOOST_FOREACH (<span class="cpp_keyword">int</span>&amp; i, ptrs|indirected) {
    <span class="cpp_keyword">if </span>(i == <span class="cpp_number_literal">0</span>)
        i = <span class="cpp_number_literal">3</span>;
}

BOOST_CHECK( oven::equals(src, answer) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/indirected.hpp&gt;</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id113" id="jointed" name="jointed">9.24&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">jointed</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">jointed</span></tt> returns a range which is jointed with its argument:</p>
<pre class="cpp_source">
std::string str0(<span class="cpp_string_literal">&quot;every range&quot;</span>);
std::vector&lt;<span class="cpp_keyword">char</span>&gt; str1 = std::string(<span class="cpp_string_literal">&quot; is&quot;</span>)|copied;
std::list&lt;<span class="cpp_keyword">char</span>&gt; str2 = std::string(<span class="cpp_string_literal">&quot; string!?&quot;</span>)|copied;

BOOST_CHECK( oven::equals(
    str0|jointed(str1)|jointed(str2),
    std::string(<span class="cpp_string_literal">&quot;every range is string!?&quot;</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/jointed.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng1|jointed(rng2)</span></tt></li>
<li>Precondition: The <tt class="docutils literal"><span class="pre">boost::range_reference</span></tt> of <tt class="docutils literal"><span class="pre">rng2</span></tt> is convertible to <tt class="docutils literal"><span class="pre">rng1</span></tt>'s without creating a rvalue.</li>
<li>Returns: A range that joints <tt class="docutils literal"><span class="pre">[boost::begin(rng1),boost::end(rng1))</span></tt> and <tt class="docutils literal"><span class="pre">[boost::begin(rng2),boost::end(rng2))</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id114" id="map-keys" name="map-keys">9.25&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">map_keys</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">map_keys</span></tt> returns a range whose values are the keys of the base associative container:</p>
<pre class="cpp_source">
std::map&lt;<span class="cpp_keyword">int</span>, std::string&gt; m;
m[<span class="cpp_number_literal">12</span>] = <span class="cpp_string_literal">&quot;hello&quot;</span>;
m[<span class="cpp_number_literal">4</span>]  = <span class="cpp_string_literal">&quot;map&quot;</span>;
m[<span class="cpp_number_literal">99</span>] = <span class="cpp_string_literal">&quot;keys&quot;</span>;

BOOST_FOREACH (<span class="cpp_keyword">int </span>k, m|map_keys) {
    BOOST_CHECK( k != <span class="cpp_number_literal">12 </span>|| m[k] == <span class="cpp_string_literal">&quot;hello&quot;</span> );
    BOOST_CHECK( k != <span class="cpp_number_literal">4  </span>|| m[k] == <span class="cpp_string_literal">&quot;map&quot;</span> );
    BOOST_CHECK( k != <span class="cpp_number_literal">99 </span>|| m[k] == <span class="cpp_string_literal">&quot;keys&quot;</span> );
}</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/map_keys.hpp&gt;</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id115" id="map-values" name="map-values">9.26&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">map_values</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">map_values</span></tt> returns a range whose values are the mapped values of the base associative container:</p>
<pre class="cpp_source">
std::map&lt;<span class="cpp_keyword">int</span>, std::string&gt; m;
m[<span class="cpp_number_literal">12</span>] = <span class="cpp_string_literal">&quot;hello&quot;</span>;
m[<span class="cpp_number_literal">4</span>]  = <span class="cpp_string_literal">&quot;map&quot;</span>;
m[<span class="cpp_number_literal">99</span>] = <span class="cpp_string_literal">&quot;keys&quot;</span>;

BOOST_FOREACH (std::string&amp; v, m|map_values) {
    <span class="cpp_keyword">if </span>(v == <span class="cpp_string_literal">&quot;keys&quot;</span>)
        v = <span class="cpp_string_literal">&quot;values&quot;</span>;
}

BOOST_CHECK( m[<span class="cpp_number_literal">12</span>] == <span class="cpp_string_literal">&quot;hello&quot;</span> );
BOOST_CHECK( m[<span class="cpp_number_literal">4</span>]  == <span class="cpp_string_literal">&quot;map&quot;</span> );
BOOST_CHECK( m[<span class="cpp_number_literal">99</span>] == <span class="cpp_string_literal">&quot;values&quot;</span> );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/map_values.hpp&gt;</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id116" id="matches" name="matches">9.27&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">matches</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/matches.hpp&gt;</span></tt>; not included by <tt class="docutils literal"><span class="pre">&lt;pstade/oven/ranges.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">biRng|matches(re)</span></tt> or <tt class="docutils literal"><span class="pre">biRng|matches(re,flag)</span></tt></li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <tt class="docutils literal"><span class="pre">boost::regex_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id117" id="memoized" name="memoized">9.28&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">memoized</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">memoized</span></tt> returns a range whose values are cached for speed, preparing for repeated dereferences:</p>
<pre class="cpp_source">
std::stringstream ss;
ss &lt;&lt; <span class="cpp_string_literal">&quot;hello, memoized!&quot;</span>;

::very_complicated_algorithm(
    oven::stream_input&lt;<span class="cpp_keyword">char</span>&gt;(ss)
        | memoized
        | directed
        | indirected
        | sorted
        | memoized
);</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/memoized.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|memoized</span></tt> and <tt class="docutils literal"><span class="pre">rng|memoized(tb)</span></tt>, where <tt class="docutils literal"><span class="pre">tb</span></tt> is a named <tt class="docutils literal"><span class="pre">memo_table</span></tt> object.</li>
<li>Precondition: <tt class="docutils literal"><span class="pre">boost::range_value</span></tt> of <tt class="docutils literal"><span class="pre">rng</span></tt> is <tt class="docutils literal"><span class="pre">CopyConstructible</span></tt>. <tt class="docutils literal"><span class="pre">tb</span></tt> has longer lifetime than the use of returned range.</li>
<li>Returns: A <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#forward_range">Forward Range</a> <a class="footnote-reference" href="#id36" id="id35" name="id35">[12]</a> whose values are memoized.</li>
</ul>
<table class="docutils footnote" frame="void" id="id36" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id35" name="id36">[12]</a></td><td><tt class="docutils literal"><span class="pre">memoized</span></tt> can return a <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#forward_range">Forward Range</a> even if the base range is a <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#single_pass_range">Single Pass Range</a>.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id118" id="merged" name="merged">9.29&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">merged</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">merged</span></tt> combines two sorted ranges into a single sorted range:</p>
<pre class="cpp_source">
std::string A1(<span class="cpp_string_literal">&quot;abbbfH&quot;</span>);
std::string A2(<span class="cpp_string_literal">&quot;ABbCDFFhh&quot;</span>);
std::string AA(<span class="cpp_string_literal">&quot;aAbbbBbCDfFFHhh&quot;</span>);
BOOST_CHECK( oven::equals(A1|merged(A2, &amp;::lt_nocase), AA) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/merged.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng1|merged(rng2)</span></tt> and <tt class="docutils literal"><span class="pre">rng1|merged(rng2,pred)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">rng1</span></tt> and <tt class="docutils literal"><span class="pre">rng2</span></tt> are sorted.</li>
<li>Returns: A constant range up to <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#forward_range">Forward Range</a> which behaves as if they were made by <tt class="docutils literal"><span class="pre">std::merge</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id119" id="permuted" name="permuted">9.30&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">permuted</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/permuted.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rndRng|permuted(rng)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">rng</span></tt> is a range of the indices of <tt class="docutils literal"><span class="pre">rndRng</span></tt>.</li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <tt class="docutils literal"><span class="pre">boost::permutation_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id120" id="pointed" name="pointed">9.31&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">pointed</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">pointed</span></tt> provides an interface to have a conversation with legacy APIs:</p>
<pre class="cpp_source">
std::string <span class="cpp_keyword">const </span>src(<span class="cpp_string_literal">&quot;hello, pointed&quot;</span>);
std::vector&lt;<span class="cpp_keyword">char</span>&gt; vec;
vec.resize(oven::distance(src) + <span class="cpp_number_literal">1</span>);
std::strcpy(boost::begin(vec|pointed), src.c_str());
BOOST_CHECK(( oven::equals(vec|null_terminated, src) ));</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/pointed.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">vec|pointed</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">vec</span></tt> is a template instantiation of <tt class="docutils literal"><span class="pre">std::vector</span></tt>.</li>
<li>Returns:  <tt class="docutils literal"><span class="pre">[&amp;*boost::begin(vec),&amp;*boost::begin(vec)+oven::distance(vec))</span></tt> if <tt class="docutils literal"><span class="pre">vec</span></tt> is not empty; otherwise, <tt class="docutils literal"><span class="pre">[0,0)</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id121" id="popped" name="popped">9.32&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">popped</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/popped.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">fwdRng|popped</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">boost::empty(fwdRng)</span> <span class="pre">==</span> <span class="pre">false</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::begin(fwdRng),boost::next(boost::begin(fwdRng),oven::distance(fwdRng)-1))</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id122" id="prepended" name="prepended">9.33&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">prepended</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/prepended.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|prepended(v)</span></tt></li>
<li>Returns: A range which behaves as if it were <tt class="docutils literal"><span class="pre">as_single(v)|jointed(rng)</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id123" id="reversed" name="reversed">9.34&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">reversed</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/reversed.hpp&gt;</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id124" id="rotated" name="rotated">9.35&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">rotated</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/rotated.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">fwdRng|rotated(fun)</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">[fun(fwdRng),boost::end(fwdRng))|jointed([boost::begin(fwdRng),fun(fwdRng)))</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id125" id="scanned" name="scanned">9.36&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">scanned</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">scanned</span></tt> is similar to <tt class="docutils literal"><span class="pre">oven::accumulate</span></tt>, but returns a range of successive reduced values from the base range:</p>
<pre class="cpp_source">
<span class="cpp_keyword">int </span><span class="cpp_keyword">const </span>src[] = { <span class="cpp_number_literal">1</span>,<span class="cpp_number_literal">2</span>,<span class="cpp_number_literal">3</span>,<span class="cpp_number_literal">4</span>,<span class="cpp_number_literal">5 </span>};
std::string null;

BOOST_FOREACH (std::string str, src|scanned(null, &amp;::stringize)) {
    std::cout &lt;&lt; <span class="cpp_string_literal">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="cpp_string_literal">&quot;\&quot; &quot;</span>;
}
<span class="cpp_comment">// outputs: &quot;&quot; &quot;1&quot; &quot;12&quot; &quot;123&quot; &quot;1234&quot; &quot;12345&quot;</span></pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/scanned.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|scanned(init,fun)</span></tt>, where the type of <tt class="docutils literal"><span class="pre">init</span></tt> is <tt class="docutils literal"><span class="pre">DefaultConstructible</span></tt>, <tt class="docutils literal"><span class="pre">CopyConstructible</span></tt> and <tt class="docutils literal"><span class="pre">CopyAssignable</span></tt>.</li>
<li>Precondition: <tt class="docutils literal"><span class="pre">fun(s,r)</span></tt> is a valid expression, where the type of <tt class="docutils literal"><span class="pre">s</span></tt> is the same as <tt class="docutils literal"><span class="pre">init</span></tt> and <tt class="docutils literal"><span class="pre">r</span></tt> is the iterator dereference of <tt class="docutils literal"><span class="pre">rng</span></tt>.</li>
<li>Returns: A range up to <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#forward_range">Forward Range</a> which behaves as if it were made by <tt class="docutils literal"><span class="pre">std::partial_sum</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id126" id="seconds" name="seconds">9.37&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">seconds</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/seconds.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|seconds</span></tt></li>
<li>Returns: A range which behave as if it were <tt class="docutils literal"><span class="pre">rng|map_values</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id127" id="set-cap" name="set-cap">9.38&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">set_cap</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/set_cap.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng1|set_cap(rng2)</span></tt> and <tt class="docutils literal"><span class="pre">rng1|set_cap(rng2,pred)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">rng1</span></tt> and <tt class="docutils literal"><span class="pre">rng2</span></tt> are sorted.</li>
<li>Returns: A constant range up to <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#forward_range">Forward Range</a> which behaves as if they were made by <tt class="docutils literal"><span class="pre">std::set_intersection</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id128" id="set-cup" name="set-cup">9.39&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">set_cup</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/set_cup.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng1|set_cup(rng2)</span></tt> and <tt class="docutils literal"><span class="pre">rng1|set_cup(rng2,pred)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">rng1</span></tt> and <tt class="docutils literal"><span class="pre">rng2</span></tt> are sorted.</li>
<li>Returns: A constant range up to <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#forward_range">Forward Range</a> which behaves as if they were made by <tt class="docutils literal"><span class="pre">std::set_union</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id129" id="set-delta" name="set-delta">9.40&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">set_delta</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/set_delta.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng1|set_delta(rng2)</span></tt> and <tt class="docutils literal"><span class="pre">rng1|set_delta(rng2,pred)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">rng1</span></tt> and <tt class="docutils literal"><span class="pre">rng2</span></tt> are sorted.</li>
<li>Returns: A constant range up to <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#forward_range">Forward Range</a> which behaves as if they were made by <tt class="docutils literal"><span class="pre">std::set_symmetric_difference</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id130" id="set-minus" name="set-minus">9.41&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">set_minus</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/set_minus.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng1|set_minus(rng2)</span></tt> and <tt class="docutils literal"><span class="pre">rng1|set_minus(rng2,pred)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">rng1</span></tt> and <tt class="docutils literal"><span class="pre">rng2</span></tt> are sorted.</li>
<li>Returns: A constant range up to <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#forward_range">Forward Range</a> which behaves as if they were made by <tt class="docutils literal"><span class="pre">std::set_difference</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id131" id="shared" name="shared">9.42&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">shared</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">shared</span></tt>, taking a pointer to heap-allocated range, makes a range whose iterators manage its lifetime:</p>
<pre class="cpp_source">
BOOST_FOREACH (<span class="cpp_keyword">char </span>ch, std::string(<span class="cpp_string_literal">&quot;dangling&quot;</span>)|identities) {
    <span class="cpp_comment">// will crash; 'std::string' object doesn't exist anymore. 
    </span>std::cout &lt;&lt; ch;
}

BOOST_FOREACH (<span class="cpp_keyword">char </span>ch, <span class="cpp_keyword">new </span>std::string(<span class="cpp_string_literal">&quot;ok&quot;</span>)|shared|identities) {
    <span class="cpp_comment">// works fine.
    </span>std::cout &lt;&lt; ch;
}</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/shared.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">p|shared</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">boost::shared_ptr</span></tt> is constructible from <tt class="docutils literal"><span class="pre">p</span></tt>.</li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <a class="reference" href="http://www.boost.org/libs/utility/shared_container_iterator.html">shared_container_iterator</a>.</li>
</ul>
<p>You can find a more elaborate example at <tt class="docutils literal"><span class="pre">&lt;pstade/oven/sorted.hpp&gt;</span></tt>.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id132" id="sliced" name="sliced">9.43&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">sliced</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">sliced</span></tt> <a class="footnote-reference" href="#id39" id="id38" name="id38">[13]</a> provides the column view of the base range:</p>
<pre class="cpp_source">
<span class="cpp_keyword">int </span><span class="cpp_keyword">const </span>answer[] = { <span class="cpp_number_literal">2</span>,<span class="cpp_number_literal">6</span>,<span class="cpp_number_literal">10</span>,<span class="cpp_number_literal">14 </span>};
BOOST_CHECK( oven::equals(answer,
    counting(<span class="cpp_number_literal">0</span>, <span class="cpp_number_literal">16</span>)|sliced(<span class="cpp_number_literal">2</span>, <span class="cpp_number_literal">4</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/sliced.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rndRng|sliced(start,stride)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">d</span> <span class="pre">==</span> <span class="pre">0</span> <span class="pre">||</span> <span class="pre">d</span> <span class="pre">%</span> <span class="pre">stride</span> <span class="pre">==</span> <span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">start</span> <span class="pre">&amp;&amp;</span> <span class="pre">start</span> <span class="pre">&lt;</span> <span class="pre">stride</span></tt>, where <tt class="docutils literal"><span class="pre">d</span> <span class="pre">=</span> <span class="pre">oven::distance(rndRng);</span></tt></li>
</ul>
<table class="docutils footnote" frame="void" id="id39" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id38" name="id39">[13]</a></td><td>This name is different from <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>'s, which is the role of <a class="reference" href="#advanced">advanced</a> or <a class="reference" href="#window">window</a>.</td></tr>
</tbody>
</table>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id133" id="string-found" name="string-found">9.44&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">string_found</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/string_found.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|string_found(finder)</span></tt></li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <tt class="docutils literal"><span class="pre">boost::algorithm::find_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id134" id="string-split" name="string-split">9.45&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">string_split</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/string_split.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|string_split(finder)</span></tt></li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <tt class="docutils literal"><span class="pre">boost::algorithm::split_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id135" id="taken" name="taken">9.46&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">taken</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">taken</span></tt>, applied to the base range, returns the prefix of the range of length <tt class="docutils literal"><span class="pre">n</span></tt>:</p>
<pre class="cpp_source">
std::string src(<span class="cpp_string_literal">&quot;hello, taken!&quot;</span>);
std::string ans(<span class="cpp_string_literal">&quot;hello&quot;</span>);
BOOST_CHECK( oven::equals(src|taken(<span class="cpp_number_literal">7</span>)|taken(<span class="cpp_number_literal">5</span>), ans) );
</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/taken.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|taken(n)</span></tt></li>
<li>Precondition: <tt class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">n</span></tt></li>
<li>Returns: A range up to <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#forward_range">Forward Range</a> which behaves as if it were <tt class="docutils literal"><span class="pre">[boost::begin(rng),boost::next(boost::begin(rng),std::min(n,</span> <span class="pre">distance(rng))))</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id136" id="taken-while" name="taken-while">9.47&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">taken_while</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">taken_while</span></tt>, applied to a <a class="reference" href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a> and the base range, returns the longest
prefix (possibly empty) of the range of elements that satisfy <a class="reference" href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>:</p>
<pre class="cpp_source">
std::string src(<span class="cpp_string_literal">&quot;11111234516313!&quot;</span>);

BOOST_CHECK( oven::equals(
    src|taken_while(lambda::_1 == <span class="cpp_string_literal">'1'</span>),
    std::string(<span class="cpp_string_literal">&quot;11111&quot;</span>)
) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/taken_while.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|taken_while(pred)</span></tt></li>
<li>Returns: A range up to <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#forward_range">Forward Range</a> which behaves as if it were <tt class="docutils literal"><span class="pre">[boost::begin(rng),oven::find_if(rng,not_(pred)))</span></tt></li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id137" id="tokenized" name="tokenized">9.48&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">tokenized</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/tokenized.hpp&gt;</span></tt>; not included by <tt class="docutils literal"><span class="pre">&lt;pstade/oven/ranges.hpp&gt;</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id138" id="transformed" name="transformed">9.49&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">transformed</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/transormed.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|transformed(rfun)</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id139" id="uniqued" name="uniqued">9.50&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">uniqued</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/uniqued.hpp&gt;</span></tt></li>
<li>See: <a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id140" id="unzipped" name="unzipped">9.51&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">unzipped</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">unzipped</span></tt> reverses <tt class="docutils literal"><span class="pre">zipped</span></tt>:</p>
<pre class="cpp_source">
std::cout &lt;&lt;
    (
        assign::list_of
            (boost::make_tuple(<span class="cpp_number_literal">1</span>,<span class="cpp_number_literal">2</span>))
            (boost::make_tuple(<span class="cpp_number_literal">2</span>,<span class="cpp_number_literal">3</span>))
            (boost::make_tuple(<span class="cpp_number_literal">3</span>,<span class="cpp_number_literal">4</span>))
            | unzipped
    );

<span class="cpp_comment">// output&gt; ({1,2,3} {2,3,4})</span></pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/unzipped.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">tuples|unzipped</span></tt>, where <tt class="docutils literal"><span class="pre">tuples</span></tt> is a range whose value_type is <tt class="docutils literal"><span class="pre">boost::tuple</span></tt>.</li>
<li>Returns: A <tt class="docutils literal"><span class="pre">boost::tuple</span></tt> whose elements are unzipped ranges.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id141" id="utf8-decoded" name="utf8-decoded">9.52&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">utf8_decoded</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/utf8_decoded.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">biRng|utf8_decoded</span></tt></li>
<li>Returns: A <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#bidirectional_range">Bidirectional Range</a> whose iterators behave as if they were the original iterators wrapped in <tt class="docutils literal"><span class="pre">boost::u8_to_u32_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id142" id="window" name="window">9.53&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">window</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/window.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">fwdRng|window(n,m)</span></tt></li>
<li>Returns: <tt class="docutils literal"><span class="pre">[boost::next(boost::begin(rng),n),boost::next(boost::begin(rng),m))</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id143" id="with-position" name="with-position">9.54&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">with_position</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/with_position.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rng|with_position</span></tt></li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <tt class="docutils literal"><span class="pre">boost::spirit::position_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id144" id="xpressive-matches" name="xpressive-matches">9.55&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">xpressive_matches</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/xpressive_matches.hpp&gt;</span></tt>; not included by <tt class="docutils literal"><span class="pre">&lt;pstade/oven/ranges.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">biRng|xpressive_matches(re)</span></tt> or <tt class="docutils literal"><span class="pre">biRng|xpressive_matches(re,flag)</span></tt></li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <tt class="docutils literal"><span class="pre">boost::xpressive::regex_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id145" id="xpressive-tokenized" name="xpressive-tokenized">9.56&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">xpressive_tokenized</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/xpressive_tokenized.hpp&gt;</span></tt>; not included by <tt class="docutils literal"><span class="pre">&lt;pstade/oven/ranges.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">biRng|xpressive_tokenized(re)</span></tt> or <tt class="docutils literal"><span class="pre">biRng|xpressive_tokenized(re,subMatches,flag)</span></tt></li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <tt class="docutils literal"><span class="pre">boost::xpressive::regex_token_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id146" id="zipped" name="zipped">9.57&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">zipped</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">zipped</span></tt> takes a tuple of ranges and returns a range of corresponding tuples.
If one input range is short, excess elements of the longer range are discarded:</p>
<pre class="cpp_source">
std::cout &lt;&lt;
    (
        boost::make_tuple(
            assign::list_of(<span class="cpp_number_literal">1</span>)(<span class="cpp_number_literal">2</span>)(<span class="cpp_number_literal">3</span>),
            assign::list_of(<span class="cpp_number_literal">2</span>)(<span class="cpp_number_literal">3</span>)(<span class="cpp_number_literal">4</span>)
        )
            | zipped
    );

<span class="cpp_comment">// output&gt; {(1 2),(2 3),(3 4)}
</span></pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/zipped.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rngs|zipped</span></tt>, where <tt class="docutils literal"><span class="pre">rngs</span></tt> is a <tt class="docutils literal"><span class="pre">boost::tuple</span></tt> of ranges.</li>
<li>Returns: A range whose iterators behave as if they were the original iterators wrapped in <tt class="docutils literal"><span class="pre">boost::zip_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id147" id="zipped-with" name="zipped-with">9.58&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">zipped_with</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">zipped_with</span></tt> generalises <tt class="docutils literal"><span class="pre">zipped</span></tt> by zipping with the <a class="reference" href="http://www.sgi.com/tech/stl/functors.html">Function Object</a>,
given as the first argument, instead of a tupling:</p>
<pre class="cpp_source">
<span class="cpp_keyword">int </span>xs[]  = { <span class="cpp_number_literal">0</span>, <span class="cpp_number_literal">1</span>, <span class="cpp_number_literal">2</span>, <span class="cpp_number_literal">3</span>, <span class="cpp_number_literal">4</span>, <span class="cpp_number_literal">5</span>, <span class="cpp_number_literal">6 </span>};
<span class="cpp_keyword">int </span>ys[]  = { <span class="cpp_number_literal">1</span>, <span class="cpp_number_literal">6</span>, <span class="cpp_number_literal">1</span>, <span class="cpp_number_literal">2</span>, <span class="cpp_number_literal">7</span>, <span class="cpp_number_literal">8</span>, <span class="cpp_number_literal">3 </span>};
<span class="cpp_keyword">int </span>ans[] = { <span class="cpp_number_literal">1</span>, <span class="cpp_number_literal">7</span>, <span class="cpp_number_literal">3</span>, <span class="cpp_number_literal">5</span>,<span class="cpp_number_literal">11</span>,<span class="cpp_number_literal">13</span>, <span class="cpp_number_literal">9 </span>};

BOOST_CHECK( oven::equals(
    boost::tie(xs, ys)|zipped_with(::plus()),
    ans
) );
</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/zipped_with.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">rngs|zipped_with(rfun)</span></tt>, where <tt class="docutils literal"><span class="pre">rngs</span></tt> is a <tt class="docutils literal"><span class="pre">boost::tuple</span></tt> of ranges.</li>
<li>Precondition1: The arity of <tt class="docutils literal"><span class="pre">rfun</span></tt> is the length of <tt class="docutils literal"><span class="pre">rngs</span></tt>.</li>
<li>Returns: A range whose values are zipped by using <tt class="docutils literal"><span class="pre">rfun</span></tt>.</li>
</ul>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id148" id="output-iterator-adaptors" name="output-iterator-adaptors">10&nbsp;&nbsp;&nbsp;Output Iterator Adaptors</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id149" id="to-counter" name="to-counter">10.1&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">to_counter</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">to_counter</span></tt> takes an initial count and increments it every output.
<a class="reference" href="#adapted-to-to-base">adapted_to/to_base</a> can extract the result of the counting:</p>
<pre class="cpp_source">
<span class="cpp_keyword">int </span><span class="cpp_keyword">const </span>rng[] = { <span class="cpp_number_literal">0</span>,<span class="cpp_number_literal">0</span>,<span class="cpp_number_literal">1</span>,<span class="cpp_number_literal">1</span>,<span class="cpp_number_literal">2</span>,<span class="cpp_number_literal">3</span>,<span class="cpp_number_literal">3</span>,<span class="cpp_number_literal">3</span>,<span class="cpp_number_literal">4</span>,<span class="cpp_number_literal">4</span>,<span class="cpp_number_literal">4</span>,<span class="cpp_number_literal">4</span>,<span class="cpp_number_literal">4</span>,<span class="cpp_number_literal">5</span>,<span class="cpp_number_literal">5 </span>};
<span class="cpp_keyword">int </span>i = oven::copy(rng|uniqued, oven::to_counter(<span class="cpp_number_literal">0</span>))|to_base;
BOOST_CHECK( i == <span class="cpp_number_literal">6 </span>);

BOOST_CHECK( <span class="cpp_number_literal">7 </span>== oven::adapted_to&lt;<span class="cpp_keyword">int</span>&gt;(oven::unique_copy(rng, oven::to_counter(<span class="cpp_number_literal">1</span>))) );</pre>

<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/to_counter.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">to_counter(i)</span></tt>, where <tt class="docutils literal"><span class="pre">i</span></tt> is an <tt class="docutils literal"><span class="pre">Incrementable</span></tt>.</li>
<li>Returns: An <tt class="docutils literal"><span class="pre">OutputIterator</span></tt> which counts the output.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id150" id="to-function" name="to-function">10.2&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">to_function</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">to_function</span></tt> returns an <tt class="docutils literal"><span class="pre">OutputIterator</span></tt> which is a port of <a class="reference" href="http://www.boost.org/libs/iterator/doc/function_output_iterator.html">boost::function_output_iterator</a>
with some workarounds.</p>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/to_function.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">to_function(fun)</span></tt></li>
<li>Returns: An <tt class="docutils literal"><span class="pre">OutputIterator</span></tt> which behaves as if it were <tt class="docutils literal"><span class="pre">boost::function_output_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id151" id="to-stream" name="to-stream">10.3&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">to_stream</span></tt></a></h2>
<p><tt class="docutils literal"><span class="pre">to_stream</span></tt> returns an <tt class="docutils literal"><span class="pre">OutputItertor</span></tt> which is a shorthand version of <tt class="docutils literal"><span class="pre">std::ostream_iterator</span></tt>.
It needs no an explicit template parameter to specify the <tt class="docutils literal"><span class="pre">value_type</span></tt> to output,
but one precondition below must be kept. Generally, the <tt class="docutils literal"><span class="pre">boost::iterator_reference</span></tt> of <tt class="docutils literal"><span class="pre">InputIterator</span></tt> must be
the same as <tt class="docutils literal"><span class="pre">value_type</span></tt> of it except for reference qualifier.</p>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/to_stream.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">to_stream(os)</span></tt></li>
<li>Precondition: The type to be assigned to dereference of an iterator which <tt class="docutils literal"><span class="pre">to_stream</span></tt> returns must be an <tt class="docutils literal"><span class="pre">OutputStreamable</span></tt>.</li>
<li>Returns: An <tt class="docutils literal"><span class="pre">OutputIterator</span></tt> which behave as if it were <tt class="docutils literal"><span class="pre">std::ostream_iterator</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id152" id="to-utf8-encoder" name="to-utf8-encoder">10.4&nbsp;&nbsp;&nbsp;<tt class="docutils literal"><span class="pre">to_utf8_encoder</span></tt></a></h2>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/to_utf8_encoder.hpp&gt;</span></tt></li>
<li>Valid expression: <tt class="docutils literal"><span class="pre">to_utf8_encoder(oit)</span></tt>, where <tt class="docutils literal"><span class="pre">oit</span></tt> is an <tt class="docutils literal"><span class="pre">OutputIterator</span></tt>.</li>
<li>Returns: An <tt class="docutils literal"><span class="pre">OutputIterator</span></tt> which behave as if it were <tt class="docutils literal"><span class="pre">boost::utf8_output_iterator</span></tt>.</li>
</ul>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id153" id="extending-boost-range" name="extending-boost-range">11&nbsp;&nbsp;&nbsp;Extending Boost.Range</a></h1>
<p><a class="reference" href="http://www.boost.org/libs/range/doc/boost_range.html#minimal_interface">The extension way of Boost.Range</a> seems to assume the future C++ ability <tt class="docutils literal"><span class="pre">decltype</span></tt>.
For now, it is not practical to apply the way to a large library something like MFC.
Oven provides yet another extension way, which is similar to
<a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2049.pdf">Conceptualizing the Range-Based for Loop</a> proposal to simplify the Boost.Range one:</p>
<pre class="cpp_source">
<span class="cpp_keyword">namespace </span>Foo {

    <span class="cpp_keyword">template</span>&lt; <span class="cpp_keyword">class </span>T &gt;
    <span class="cpp_keyword">struct </span>Pair
    {
        T first, last;
    };

} <span class="cpp_comment">// namespace Foo

</span><span class="cpp_keyword">namespace </span>pstade_oven_extension {

    <span class="cpp_keyword">template</span>&lt; <span class="cpp_keyword">class </span>T &gt;
    <span class="cpp_keyword">struct </span>Range&lt; Foo::Pair&lt;T&gt; &gt;
    {
        <span class="cpp_comment">// X == Foo::Pair&lt;T&gt;
        </span><span class="cpp_keyword">template</span>&lt; <span class="cpp_keyword">class </span>X &gt;
        <span class="cpp_keyword">struct </span>associate
        {
            <span class="cpp_keyword">typedef </span>T mutable_iterator;
            <span class="cpp_keyword">typedef </span>T constant_iterator;
        };

        <span class="cpp_comment">// if X is not const, Iterator == mutable_iterator;
        </span><span class="cpp_comment">// otherwise, Iterator == constant_iterator.
        </span><span class="cpp_keyword">template</span>&lt; <span class="cpp_keyword">class </span>Iterator, <span class="cpp_keyword">class </span>X &gt;
        Iterator begin(X&amp; x)
        {
            <span class="cpp_keyword">return </span>x.first;
        }

        <span class="cpp_keyword">template</span>&lt; <span class="cpp_keyword">class </span>Iterator, <span class="cpp_keyword">class </span>X &gt;
        Iterator end(X&amp; x)
        {
            <span class="cpp_keyword">return </span>x.last;
        }
    };

} <span class="cpp_comment">// namespace pstade_oven_extension

</span>PSTADE_OVEN_EXTENSION_OF_TEMPLATE((Foo)(Pair), (<span class="cpp_keyword">class</span>))
<span class="cpp_comment">// PSTADE_OVEN_EXTENSION_OF_TEMPLATE((Foo)(Pair), 1) // also ok.</span></pre>

<ol class="arabic simple">
<li>Specialize <tt class="docutils literal"><span class="pre">::pstade_oven_extension::Range</span></tt>.</li>
<li>Define template <tt class="docutils literal"><span class="pre">associate</span></tt>, <tt class="docutils literal"><span class="pre">begin</span></tt> and <tt class="docutils literal"><span class="pre">end</span></tt>.</li>
<li>Call the macro, in global namespace, to act as a bridge between Oven and Boost.Range.</li>
</ol>
<p>Note that the const overloads can be sometimes omitted like above.
Also, <tt class="docutils literal"><span class="pre">Range</span></tt> has the second template parameter for <tt class="docutils literal"><span class="pre">pstade::enable_if</span></tt>.
<tt class="docutils literal"><span class="pre">boost::size</span></tt> is automatically extended by Oven.</p>
<ul class="simple">
<li>Header: <tt class="docutils literal"><span class="pre">&lt;pstade/oven/extension.hpp&gt;</span></tt></li>
<li>Valid expression1: <tt class="docutils literal"><span class="pre">PSTADE_OVEN_EXTENSION_OF_TYPE(X)</span></tt></li>
<li>Valid expression2: <tt class="docutils literal"><span class="pre">PSTADE_OVEN_EXTENSION_OF_TEMPLATE(X,N)</span></tt>, where <tt class="docutils literal"><span class="pre">N</span></tt> is the number of template arguments. Only valid if all template arguments are typenames.</li>
<li>Valid expression3: <tt class="docutils literal"><span class="pre">PSTADE_OVEN_EXTENSION_OF_TEMPLATE(X,S)</span></tt>, where <tt class="docutils literal"><span class="pre">S</span></tt> is a sequence of template arguments. Must be used when integral or template template parameters are present.</li>
<li>Precondition: <tt class="docutils literal"><span class="pre">X</span></tt> is a Boost.Preprocessor Sequence of type name.</li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id154" id="mfc-atl-extension" name="mfc-atl-extension">12&nbsp;&nbsp;&nbsp;MFC/ATL Extension</a></h1>
<p>Oven provides <a class="reference" href="http://www.boost.org/libs/range/">Boost.Range</a> support for MFC/ATL collection and string types.
See <a class="reference" href="./doc/ms/mfc_atl.html">Oven Range MFC/ATL Extension</a>.</p>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id155" id="acknowledgments" name="acknowledgments">13&nbsp;&nbsp;&nbsp;Acknowledgments</a></h1>
<ul class="simple">
<li><a class="reference" href="http://p-stade.sourceforge.net/">P-Stade</a></li>
<li><a class="reference" href="http://www.boost.org/">Boost C++ Libraries</a></li>
<li><a class="reference" href="http://www.boost.org/libs/range/">Boost.Range</a></li>
<li><a class="reference" href="http://boost-consulting.com/vault/index.php?&amp;directory=Algorithms">Boost.RangeEx</a></li>
<li><a class="reference" href="http://www.flll.jku.at/staff/private/roland/view/">Boost.View</a></li>
<li><a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2068.html">Range Library Core</a></li>
<li><a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1871.html">Range Library Proposal</a></li>
<li><a class="reference" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2059.html">Proposal for new string algorithms in TR2</a></li>
<li><a class="reference" href="http://sourceforge.jp/projects/cradle/">Cradle - A C++ Sandbox</a></li>
<li><a class="reference" href="http://www.torjo.com/rangelib/index.html">RangeLib - The Boost Iterable Range Library</a></li>
<li><a class="reference" href="http://www.zib.de/weiser/vtl/">VTL (View Template Library)</a></li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id156" id="release-notes" name="release-notes">14&nbsp;&nbsp;&nbsp;Release Notes</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id157" id="version-0-90-0" name="version-0-90-0">14.1&nbsp;&nbsp;&nbsp;Version 0.90.0</a></h2>
<ul class="simple">
<li>Released initial version.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id158" id="version-0-90-1-0-90-6" name="version-0-90-1-0-90-6">14.2&nbsp;&nbsp;&nbsp;Version 0.90.1 - 0.90.6</a></h2>
<ul class="simple">
<li>Updated this document.</li>
<li>Implemented <a class="reference" href="#range-algorithms">Range Algorithms</a>.</li>
<li>Added some <a class="reference" href="#ranges">Ranges</a> and <a class="reference" href="#range-adaptors">Range Adaptors</a>.</li>
<li>Added some <a class="reference" href="#range-adaptors">Range Adaptors</a>.</li>
<li>Changed the header of <a class="reference" href="#permuted">permuted</a>.</li>
<li>Changed the header of <tt class="docutils literal"><span class="pre">pointed</span></tt>.</li>
<li>Changed a valid expression of <a class="reference" href="#zipped">zipped</a>.</li>
<li>Changed <a class="reference" href="#checked">checked</a> to throw exception.</li>
<li>Renamed <tt class="docutils literal"><span class="pre">found</span></tt> to <a class="reference" href="#string-found">string_found</a>.</li>
<li>Changed the header of <a class="reference" href="#range-algorithms">Range Algorithms</a>.</li>
<li>Added <tt class="docutils literal"><span class="pre">base_iterator</span></tt>.</li>
<li>Added some <a class="reference" href="#range-adaptors">Range Adaptors</a>.</li>
<li>Renamed <tt class="docutils literal"><span class="pre">accumulated</span></tt> to <a class="reference" href="#scanned">scanned</a>.</li>
<li>Added workaround for <a class="reference" href="http://std.dkuug.dk/jtc1/sc22/wg21/docs/lwg-defects.html#198">Standard Library Defect #198</a>.</li>
<li>Changed <a class="reference" href="#constants">constants</a> semantics, and added <a class="reference" href="#always">always</a> instead.</li>
<li>Changed <a class="reference" href="#utf8-decoded">utf8_decoded</a> valid expression.</li>
<li><a class="reference" href="#shared">shared</a> accepts <tt class="docutils literal"><span class="pre">auto_ptr</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id159" id="version-0-90-7-0-90-9" name="version-0-90-7-0-90-9">14.3&nbsp;&nbsp;&nbsp;Version 0.90.7 - 0.90.9</a></h2>
<ul class="simple">
<li>Added <tt class="docutils literal"><span class="pre">matched</span></tt>, <tt class="docutils literal"><span class="pre">xpressive_matched</span></tt> and <tt class="docutils literal"><span class="pre">xpressive_tokenized</span></tt>.</li>
<li>Renamed <tt class="docutils literal"><span class="pre">base_iterator</span></tt> to <tt class="docutils literal"><span class="pre">to_base</span></tt>.</li>
<li>Renamed <tt class="docutils literal"><span class="pre">copied</span></tt> adaptor to <tt class="docutils literal"><span class="pre">copied_to</span></tt>.</li>
<li>Added <a class="reference" href="#concatenated">concatenated</a>.</li>
<li>Renamed <tt class="docutils literal"><span class="pre">copied_to</span></tt> to <tt class="docutils literal"><span class="pre">copied_out</span></tt>.</li>
<li>Fixed a bug of <tt class="docutils literal"><span class="pre">transformed</span></tt> and <tt class="docutils literal"><span class="pre">concatenated</span></tt>.</li>
<li>Added <tt class="docutils literal"><span class="pre">generated</span></tt>.</li>
<li>No longer supports function types as <tt class="docutils literal"><span class="pre">rfun</span></tt>.</li>
<li>Changed <a class="reference" href="#utf8-decoded">utf8_decoded</a> valid expression.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id160" id="version-0-91-0-0-91-3" name="version-0-91-0-0-91-3">14.4&nbsp;&nbsp;&nbsp;Version 0.91.0 - 0.91.3</a></h2>
<ul class="simple">
<li>Added <a class="reference" href="#output-iterator-adaptors">Output Iterator Adaptors</a>.</li>
<li>Renamed <tt class="docutils literal"><span class="pre">generated</span></tt> to <tt class="docutils literal"><span class="pre">generation</span></tt>.</li>
<li>Renamed <tt class="docutils literal"><span class="pre">positioned</span></tt> to <tt class="docutils literal"><span class="pre">with_position</span></tt>.</li>
<li>Renamed <tt class="docutils literal"><span class="pre">matched</span></tt> to <tt class="docutils literal"><span class="pre">matches</span></tt>.</li>
<li>Renamed <tt class="docutils literal"><span class="pre">xpressive_matched</span></tt> to <tt class="docutils literal"><span class="pre">xpressive_matches</span></tt>.</li>
<li>Added <a class="reference" href="#extending-boost-range">Extending Boost.Range</a>.</li>
<li>Rejected <tt class="docutils literal"><span class="pre">out_placed</span></tt> and <tt class="docutils literal"><span class="pre">sorted</span></tt>.</li>
<li>Added <tt class="docutils literal"><span class="pre">literal_range</span></tt> and <tt class="docutils literal"><span class="pre">c_str_range</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">null_terminated</span></tt> no longer supports c-string.</li>
<li>Added <tt class="docutils literal"><span class="pre">as_single</span></tt> to <tt class="docutils literal"><span class="pre">single_range</span></tt>'s valid expressions.</li>
<li>Added <tt class="docutils literal"><span class="pre">begins/ends</span></tt>.</li>
<li>Added <tt class="docutils literal"><span class="pre">merged</span></tt>, <tt class="docutils literal"><span class="pre">set_cup</span></tt>, <tt class="docutils literal"><span class="pre">set_cap</span></tt>, <tt class="docutils literal"><span class="pre">set_minus</span></tt> and <tt class="docutils literal"><span class="pre">set_delta</span></tt>.</li>
<li>Added <tt class="docutils literal"><span class="pre">rotated</span></tt>.</li>
<li>Removed <tt class="docutils literal"><span class="pre">stridden</span></tt> and changed effects of <tt class="docutils literal"><span class="pre">sliced</span></tt>.</li>
<li>Added <tt class="docutils literal"><span class="pre">through_window</span></tt>.</li>
<li>Added <tt class="docutils literal"><span class="pre">popped</span></tt>.</li>
<li>Changed the valid expression of <tt class="docutils literal"><span class="pre">array_protect_range</span></tt> and <tt class="docutils literal"><span class="pre">literal_range</span></tt>.</li>
<li>Added <tt class="docutils literal"><span class="pre">to_function</span></tt>.</li>
<li>Renamed <tt class="docutils literal"><span class="pre">shifted</span></tt> to <tt class="docutils literal"><span class="pre">advanced</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id161" id="version-0-91-4-0-91-9" name="version-0-91-4-0-91-9">14.5&nbsp;&nbsp;&nbsp;Version 0.91.4 - 0.91.9</a></h2>
<ul class="simple">
<li>Added <tt class="docutils literal"><span class="pre">any_range</span></tt>.</li>
<li>Removed <tt class="docutils literal"><span class="pre">popped</span></tt> and changed the valid expression of <tt class="docutils literal"><span class="pre">advanced</span></tt>.</li>
<li>Removed <tt class="docutils literal"><span class="pre">generation</span></tt> as adaptor and added it as range.</li>
<li><tt class="docutils literal"><span class="pre">taken</span></tt> and <tt class="docutils literal"><span class="pre">taken_while</span></tt> supports <a class="reference" href="http://www.boost.org/libs/range/doc/range.html#single_pass_range">Single Pass Range</a>.</li>
<li>Added <tt class="docutils literal"><span class="pre">iterate_range</span></tt>.</li>
<li>Added <tt class="docutils literal"><span class="pre">adjacent_transformed</span></tt>.</li>
<li>Added <tt class="docutils literal"><span class="pre">popped_back</span></tt>.</li>
<li>Changed <tt class="docutils literal"><span class="pre">counting_range</span></tt> valid expressions.</li>
<li>Renamed <tt class="docutils literal"><span class="pre">repeated</span></tt> to <tt class="docutils literal"><span class="pre">cycled</span></tt>.</li>
<li>Added <tt class="docutils literal"><span class="pre">repeat_range</span></tt>.</li>
<li>Renamed <tt class="docutils literal"><span class="pre">popped_back</span></tt> to <tt class="docutils literal"><span class="pre">popped</span></tt>.</li>
<li>Changed the valid expressions of <tt class="docutils literal"><span class="pre">zipped</span></tt> and <tt class="docutils literal"><span class="pre">zipped_with</span></tt>.</li>
<li>Ported to VC++7.1 SP1.</li>
<li>Added MFC/ATL support.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id162" id="version-0-92-0-0-92-3" name="version-0-92-0-0-92-3">14.6&nbsp;&nbsp;&nbsp;Version 0.92.0 - 0.92.3</a></h2>
<ul class="simple">
<li>Renamed <tt class="docutils literal"><span class="pre">counting_range</span></tt> to <tt class="docutils literal"><span class="pre">count_range</span></tt>, and added a valid expression.</li>
<li>Removed the valid expression <tt class="docutils literal"><span class="pre">advanced(d)</span></tt>.</li>
<li>Renamed <tt class="docutils literal"><span class="pre">tie</span></tt> to <tt class="docutils literal"><span class="pre">pack</span></tt>.</li>
<li>Added <tt class="docutils literal"><span class="pre">boost::result_of</span></tt> support to range-based algorithms.</li>
<li>Renamed <a class="reference" href="#extending-boost-range">Extending Boost.Range</a> macros.</li>
<li>Renamed <tt class="docutils literal"><span class="pre">adaptor_to</span></tt> to <tt class="docutils literal"><span class="pre">adapted_to</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id163" id="version-0-93-0" name="version-0-93-0">14.7&nbsp;&nbsp;&nbsp;Version 0.93.0</a></h2>
<ul class="simple">
<li>Changed the names of some functions and headers.</li>
<li>Added <tt class="docutils literal"><span class="pre">delimited</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id164" id="version-0-93-1" name="version-0-93-1">14.8&nbsp;&nbsp;&nbsp;Version 0.93.1</a></h2>
<ul class="simple">
<li>Renamed <tt class="docutils literal"><span class="pre">begins/ends</span></tt> to <tt class="docutils literal"><span class="pre">begin/end</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">adjacent_transformed</span></tt> rejects empty range.</li>
<li>Changed template parameter of <tt class="docutils literal"><span class="pre">any_range</span></tt>.</li>
<li>Replaced <tt class="docutils literal"><span class="pre">regularized</span></tt> with <tt class="docutils literal"><span class="pre">regular</span></tt>.</li>
<li>Removed <tt class="docutils literal"><span class="pre">to_regularized_function</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">scanned</span></tt> range contains the <tt class="docutils literal"><span class="pre">init</span></tt> as the first element.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id165" id="version-0-93-2" name="version-0-93-2">14.9&nbsp;&nbsp;&nbsp;Version 0.93.2</a></h2>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">taken</span></tt> and <tt class="docutils literal"><span class="pre">taken_while</span></tt> behave lazily.</li>
<li><tt class="docutils literal"><span class="pre">taken</span></tt> and <tt class="docutils literal"><span class="pre">taken_while</span></tt> now return only up to ForwardRange.</li>
<li><tt class="docutils literal"><span class="pre">dropped</span></tt> and <tt class="docutils literal"><span class="pre">taken</span></tt> accept <tt class="docutils literal"><span class="pre">n</span></tt> which is larger than the distance.</li>
<li>Removed <tt class="docutils literal"><span class="pre">null_terminated</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">as_c_str</span></tt> accepts a range.</li>
<li><tt class="docutils literal"><span class="pre">zipped</span></tt> and <tt class="docutils literal"><span class="pre">zipped_with</span></tt> accept any tuple.</li>
<li>Removed <tt class="docutils literal"><span class="pre">generation_copied</span></tt>.</li>
<li>Added <tt class="docutils literal"><span class="pre">shared_regular</span></tt> and <tt class="docutils literal"><span class="pre">innumerable</span></tt>.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id166" id="version-0-93-3" name="version-0-93-3">14.10&nbsp;&nbsp;&nbsp;Version 0.93.3</a></h2>
<ul class="simple">
<li>Fixed a bug of <tt class="docutils literal"><span class="pre">generation</span></tt>.</li>
<li>Added <tt class="docutils literal"><span class="pre">front</span></tt> and <tt class="docutils literal"><span class="pre">back</span></tt>.</li>
<li>Added <tt class="docutils literal"><span class="pre">recursion</span></tt>.</li>
</ul>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference" href="doc/index.rst">View document source</a>.
Generated on: 2007-02-15 06:29 UTC.
Generated by <a class="reference" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
