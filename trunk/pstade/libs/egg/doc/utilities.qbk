[section Utilities]

It is difficult or even impossible to get a __FUNCTION_OBJECT__ from a function template.
Egg no longer considers function templates to be useful, so that it provides
"objectified" functions which replace some famous function templates.

[import ../example/nested_lambda.cpp]
[import ../example/infix_apply.cpp]




[section apply]

[heading Description]
`apply` calls a function with trailing arguments.

[heading Header]
* `<pstade/egg/apply.hpp>`

[heading Model of]
* __STATIC_FUNCTION_OBJECT__

[heading Notation]
* ...

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`apply(f, a1,...,aN)`]
        [`f(_arg_list(a, by_perfect))`]
    ]
]

[heading Preconditions]
* `0 <= N && N <= PSTADE_MAX_ARITY-1`.
* The corresponding semantics is a valid expression.


[heading Example]
[code_infix_apply_example]

[heading See also]

[endsect]




[section lambda_bind]

[heading Description]
`lambda_bind` is a __STATIC_FUNCTION_OBJECT__ which represents `boost::lambda::bind`.

[heading Header]
* `<pstade/egg/lambda/bind.hpp>`

[heading Model of]
* __STATIC_FUNCTION_OBJECT__

[heading Notation]
* ...

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`lambda_bind(f, a1,...,aN)`]
        [`boost::lambda::bind(f, a1,...,aN)`]
    ]
]

[heading Preconditions]
* `0 <= N && N <= 9`.
* The corresponding semantics is a valid expression.


[heading Example]
[code_lambda_bind_example]

[heading See also]
* __BOOST_LAMBDA__
* __EGG_LAZY__

[endsect]




[section lambda_N]

[heading Description]
`lambda_N` is a __STATIC_FUNCTION_OBJECT__ which represents `boost::lambda::_N`.

[heading Header]
* `<pstade/egg/lambda/placeholders.hpp>`

[heading Model of]
* __STATIC_FUNCTION_OBJECT__ but not a /POD/ type.

[heading Notation]
* ...

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`lambda_++N`]
        [`boost::lambda::_++N`]
    ]
]

[heading Preconditions]
* `1 <= N && N <= 3`.
* The corresponding semantics is a valid expression.

[heading Example]
...

[heading See also]
* __BOOST_LAMBDA__

[endsect]




[section lambda/result_of.hpp]

[heading Description]
This header lets a __BOOST_LAMBDA__ functor be a __DEFERRED_CALLABLE_OBJECT__.

[heading Header]
* `<pstade/egg/lambda/result_of.hpp>`

[heading Model of]
* ...

[heading Notation]
* ...

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`#include <pstade/egg/lambda/result_of.hpp>`]
        [A __BOOST_LAMBDA__ functor becomes a __DEFERRED_CALLABLE_OBJECT__.]
    ]
]

[heading Preconditions]
* ...

[heading Example]
...

[heading See also]
* __BOOST_LAMBDA__

[endsect]




[section infix]

[heading Description]
Egg provides __FCPP__ infix operator syntax.

[heading Header]
* `<pstade/egg/infix.hpp>`

[heading Model of]
* ...

[heading Notation]
* ...

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`a1 ^_dco^ a2`]
        [`_dco(_arg_list(a1, by_perfect), _arg_list(a2, by_perfect))`]
    ]
]

[heading Preconditions]
* `using namespace infix;` is placed before the valid expression.
* The corresponding semantics is a valid expression.

[heading Invariants]
* `^_dco^` behaves as if it had left to right associativity.

[heading Example]
    using namespace infix;
    BOOST_CHECK( (10 ^plus^ 12 ^plus^ 3) == 25 );

[heading See also]
* __FCPP__

[endsect]




[section tuple_get]

[heading Description]
`tuple_get` is akin to `boost::get`.

[heading Header]
* `<pstade/egg/tuple/get.hpp>`

[heading Model of]
* ...

[heading Notation]
* ...

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`X_tuple_get<N>`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ type]
    ]
    [
        [`X_tuple_get<N>()(t)`]
        [`boost::get<N::value>(t)`]
    ]
    [
        [`X_tuple_get_c<n>`]
        [`X_tuple_get< boost::mpl::int_<n> >`]
    ]
    [
        [`egg::tuple_get<N>(t)`]
        [`X_tuple_get<N>()(t)`]
    ]
    [
        [`egg::tuple_get_c<n>(t)`]
        [`X_tuple_get_c<n>()(t)`]
    ]
]

[heading Preconditions]
* The corresponding semantics is a valid expression.

[heading Example]
...

[heading See also]
* __BOOST_TUPLE__

[endsect]




[section tuple_pack]

[heading Description]
`tuple_pack` is a __STATIC_FUNCTION_OBJECT__ which represents `boost::tie` but /const-qualifier/ sensitive.

[heading Header]
* `<pstade/egg/tuple/pack.hpp>`

[heading Model of]
* __STATIC_FUNCTION_OBJECT__

[heading Notation]
* `_refs(c1,...,cK)` is `c1&,...,cK&`.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`tuple_pack(a1,...,aN)`]
        [`boost::tuple<_refs(_meta_arg_list(a, by_perfect))>(_arg_list(a, by_perfect))`]
    ]
    [
        [`tuple_pack_by_ref(a1,...,aN)`]
        [`boost::tuple<_refs(_meta_arg_list(a, by_ref))>(_arg_list(a, by_ref))`]
    ]
]

[heading Preconditions]
* The corresponding semantics is a valid expression.

[heading Example]
...

[heading See also]
* __BOOST_TUPLE__

[endsect]




[endsect]
