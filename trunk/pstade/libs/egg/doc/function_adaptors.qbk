[section Function Adaptors]

[import ../example/function_adaptors.cpp]

Function Adaptor is a higher-order function that takes a __FUNCTION_OBJECT__
and returns an adapted __FUNCTION_OBJECT__.
Function Adaptor provides two interfaces :A normal higher-order __FUNCTION_OBJECT__, and
a __METAFUNCTION__ with the corresponding macro for /static-initialization/.

[note These macros might be cumbersome, but initializers tend to contain commas and
      lazy expansion of /function-like/ macro is very limited even if using `BOOST_PP_IDENTITY` or whatever. ]




[section auxiliaryN]

[heading Description]
`auxiliary` family makes an __AUXILIARY_INTERFACE__ from the base __FUNCTION_OBJECT__.

[heading Header]
* `<pstade/egg/auxiliary.hpp>`

[heading Model of]
* __OPERATABLE_OBJECT__
* __BINDABLE_OBJECT__

[heading Notation]
* `res` is an object of `result_of_auxiliary++N<_typeof(_dco)>::type` initialized using `_dco`.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`result_of_auxiliary++N<_Dco>::type`]
        [A __BINDABLE__ __AUXILIARY_INTERFACE__ type]
    ]
    [
        [`PSTADE_EGG_AUXILIARY_L init PSTADE_EGG_AUXILIARY_R`]
        [A braced initializer of `result_of_auxiliary++N<_Dco>::type`]
    ]
    [
        [`auxiliary++N`]
        [A __BINDABLE__ __OPERATABLE_OBJECT__]
    ]
    [
        [`auxiliary++N(_dco)`]
        [`res`]
    ]
    [
        [`res(x(1),...,x(N+1))`]
        [`_dco(x(1),...,x(N+1))`]
    ]
]

[heading Preconditions]
* `N+1` is the arity of `_Dco` such that `0 <= N && N <= 5`.
* `_Dco d = init;` is a valid expression.
* `_dco(x(1),...,x(N+1))` is a valid expression.

[heading Invariants]
* If `_Dco` is /POD/, `result_of_auxiliary++N<_Dco>::type` is /POD/.

[note Arguments passed to `res` are not copied.
      Those are bound to references, then forwarded to the base __FUNCTION_OBJECT__.]

[heading Example]
[code_auxiliary_example]

[heading See also]
* __EGG_PIPABLE__

[endsect]




[section compose1]

[heading Description]
`compose1` is a Function Adaptor for function composition.

[heading Header]
* `<pstade/egg/compose1.hpp>`

[heading Model of]
* __OPERATABLE_OBJECT__
* __BINDABLE_OBJECT__

[heading Notation]
* `res` is an object of `result_of_compose1<_typeof(_dco1),_typeof(_dco2)>::type`  initialized using `_dco1` and `_dco2`.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`result_of_compose1<_Dco1, _Dco2>::type`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ type]
    ]
    [
        [`PSTADE_EGG_COMPOSE1_L init1 PSTADE_EGG_COMPOSE1_M init2 PSTADE_EGG_COMPOSE1_R`]
        [A braced initializer of `result_of_compose1<_Dco1, _Dco2>::type`]
    ]
    [
        [`compose1(_dco1, _dco2)`]
        [`res`]
    ]
    [
        [`res(x1,...,xN)`]
        [`_dco1(_dco2(x1,...,xN))`]
    ]
]

[heading Preconditions]
* `1 <= N && N <= 5`.
* `_Dco1 d1 = init1; _Dco2 d2 = init2;` is a valid expression.
* `_dco1(_dco2(x1,...,xN))` is a valid expression.

[heading Invariants]
* If `_Dco1` and `_Dco2` is /POD/, `result_of_compose1<_Dco1, _Dco2>::type` is /POD/.

[heading Example]
...

[heading See also]
* ...

[endsect]




[section curryN]

[heading Description]
`curry` family turns a base __FUNCTION_OBJECT__ into curried one.

[heading Header]
* `<pstade/egg/curry.hpp>`

[heading Model of]
* __OPERATABLE_OBJECT__
* __BINDABLE_OBJECT__

[heading Notation]
* `res` is an object of `result_of_curry++N<_typeof(_dco)>::type` initialized using `_dco`.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`result_of_curry++N<_Dco>::type`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ type]
    ]
    [
        [`PSTADE_EGG_CURRY++N++_L init PSTADE_EGG_CURRY++N++_R`]
        [A braced initializer of `result_of_curry++N<_Dco>::type`]
    ]
    [
        [`curry++N`]
        [A __BINDABLE__ __OPERATABLE_OBJECT__]
    ]
    [
        [`curry++N(_dco)`]
        [`res`]
    ]
    [
        [`res(x1)...(xN)`]
        [`_dco(x1,...,xN)`]
    ]
]

[heading Preconditions]
* `N` is the arity of `_Dco` such that `2 <= N && N <= 5`.
* `_Dco d = init;` is a valid expression.
* `_dco(x1,...,xN)` is a valid expression.

[heading Invariants]
* If `_Dco` is /POD/, `result_of_curry++N<_Dco>::type` is /POD/.

[heading Example]
[code_curry_example]

[heading See also]
* [@http://en.wikipedia.org/wiki/Currying Currying]
* __EGG_UNCURRY__

[endsect]




[section uncurry]

[heading Description]
`uncurry` reverses `curry`.

[heading Header]
* `<pstade/egg/uncurry.hpp>`

[heading Model of]
* __OPERATABLE_OBJECT__
* __BINDABLE_OBJECT__

[heading Notation]
* `res` is an object of `result_of_uncurry<_typeof(_dco)>::type` initialized using `_dco`.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`result_of_uncurry<_Dco>::type`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ type]
    ]
    [
        [`PSTADE_EGG_UNCURRY_L init PSTADE_EGG_UNCURRY_R`]
        [A braced initializer of `result_of_uncurry<_Dco>::type`]
    ]
    [
        [`uncurry(_dco)`]
        [`res`]
    ]
    [
        [`res(x1,...,xN)`]
        [`_dco(x1)...(xN)`]
    ]
]

[heading Preconditions]
* `2 <= N && N <= 5`.
* `_Dco d = init;` is a valid expression.
* `_dco(x1)...(xN)` is a valid expression.

[heading Invariants]
* If `_Dco` is /POD/, `result_of_uncurry<_Dco>::type` is /POD/.

[heading See also]
* [@http://en.wikipedia.org/wiki/Currying Currying]
* __EGG_CURRY__

[endsect]




[section fuse]

[heading Description]
`fuse` converts the base __FUNCTION_OBJECT__ into a unary __FUNCTION_OBJECT__ which takes a tuple.

[heading Header]
* `<pstade/egg/fuse.hpp>`

[heading Model of]
* __OPERATABLE_OBJECT__
* __BINDABLE_OBJECT__

[heading Notation]
* `res` is an object of `result_of_fuse<_typeof(_dco)>::type` initialized using `_dco`.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`result_of_fuse<_Dco>::type`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ type]
    ]
    [
        [`PSTADE_EGG_FUSE_L init PSTADE_EGG_FUSE_R`]
        [A braced initializer of `result_of_fuse<_Dco>::type`]
    ]
    [
        [`fuse(_dco)`]
        [`res`]
    ]
    [
        [`res(t)`]
        [`_dco(boost::get<0>(t),...,boost::get<N-1>(t))`]
    ]
    [
        [`res(t0)`]
        [`_dco()`]
    ]
]

[heading Preconditions]
* `1 <= N && N <= 10`.
* `_Dco d = init;` is a valid expression.
* `t0` is an empty tuple.
* The corresponding semantics is a valid expression.

[heading Invariants]
* If `_Dco` is /POD/, `result_of_fuse<_Dco>::type` is /POD/.

[heading See also]
* [@http://boost-consulting.com/boost/libs/fusion/doc/html/fusion/functional/adapters.html Fusion Functional Adaptors]
* __EGG_UNFUSE__

[endsect]




[section unfuse]

[heading Description]
`unfuse` reverses `fuse`.

[heading Header]
* `<pstade/egg/unfuse.hpp>`

[heading Model of]
* __OPERATABLE_OBJECT__
* __BINDABLE_OBJECT__

[heading Notation]
* `res` is an object of `result_of_unfuse<_typeof(_dco)>::type` initialized using `_dco`.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`result_of_unfuse<_Dco>::type`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ type]
    ]
    [
        [`PSTADE_EGG_UNFUSE_L init PSTADE_EGG_UNFUSE_M {} PSTADE_EGG_UNFUSE_R`]
        [A braced initializer of `result_of_unfuse<_Dco>::type`]
    ]
    [
        [`unfuse(_dco)`]
        [`res`]
    ]
    [
        [`res(a1,...,aN)`]
        [`_dco(boost::tuple<_decltype(a1),..._decltype(aN)>(a1,...,aN))`]
    ]
]

[heading Preconditions]
* `1 <= N && N <= 5`.
* `_Dco d = init;` is a valid expression.
* The corresponding semantics is a valid expression.

[heading Invariants]
* If `_Dco` is /POD/, `result_of_unfuse<_Dco>::type` is /POD/.

[heading Example]
...

[heading See also]
* [@http://boost-consulting.com/boost/libs/fusion/doc/html/fusion/functional/adapters.html Fusion Functional Adaptors]
* __EGG_FUSE__

[endsect]




[section indirect]

[heading Description]
`indirect` takes a pointer-like object then calls it after dereferencing.

[heading Header]
* `<pstade/egg/indirect.hpp>`

[heading Model of]
* __OPERATABLE_OBJECT__
* __BINDABLE_OBJECT__

[heading Notation]
* `res` is an object of `result_of_indirect<_typeof(Pco)>::type` initialized using `pco`.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`result_of_indirect<Pco>::type`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ type]
    ]
    [
        [`PSTADE_EGG_INDIRECT_L init PSTADE_EGG_INDIRECT_R`]
        [A braced initializer of `result_of_indirect<Pco>::type`]
    ]
    [
        [`indirect(pco)`]
        [`res`]
    ]
    [
        [`res(a1,...,aN)`]
        [`(*pco)(a1,...,aN)`]
    ]
]

[heading Preconditions]
* `1 <= N && N <= 5`.
* `boost::pointee<Pco>::type` is __DEFERRED_CALLABLE_OBJECT__ type.
* `Pco p = init;` is a valid expression.
* The corresponding semantics is a valid expression.

[heading Example]
[code_indirect_example]

[heading See also]
* __BOOST_INDIRECT_ITERATOR__

[endsect]




[section lazy]

[heading Description]
__BOOST_PHOENIX__ is able to make a lambda expression without a "bind function".
`lazy` turns a base __FUNCTION_OBJECT__ into such one which can be used with __BOOST_LAMBDA__.

[heading Header]
* `<pstade/egg/lazy.hpp>`

[heading Model of]
* __OPERATABLE_OBJECT__
* __BINDABLE_OBJECT__

[heading Notation]
* `res` is an object of `result_of_lazy<_typeof(_Dco)>::type` initialized using `_dco`.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`result_of_lazy<_Dco>::type`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ type]
    ]
    [
        [`PSTADE_EGG_LAZY_L init PSTADE_EGG_LAZY_R`]
        [A braced initializer of `result_of_lazy<_Dco>::type`]
    ]
    [
        [`lazy(_dco)`]
        [`res`]
    ]
    [
        [`res(a1,...,aN)`]
        [`boost::lambda::bind(_dco, a1,...,aN)`]
    ]
]

[heading Preconditions]
* `0 <= N && N <= 5`.
* `_Dco d = init;` is a valid expression.
* The corresponding semantics is a valid expression, meaning that `_Dco` is a __BINDABLE_OBJECT__ type.

[heading Example]
[code_lazy_example]

[heading See also]
* __BOOST_PHOENIX__

[endsect]




[section memoize]

[heading Description]
`memoize` stores the result of function for later reuse.

[heading Header]
* `<pstade/egg/memoize.hpp>`

[heading Model of]
* __OPERATABLE_OBJECT__
* __BINDABLE_OBJECT__

[heading Notation]
* `fixed` is an unspecified unary __FUNCTION_OBJECT__ which represents `_dco` itself.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`memoize(_dco)`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__]
    ]
    [
        [`memoize(_dco)(a1)`]
        [`_dco(fixed, a1)`]
    ]
]

[note `memoize` doesn't offer the way to /static-initialize/ a memoized __FUNCTION_OBJECT__.]

[heading Preconditions]
* The corresponding semantics is a valid expression.
* A __FUNCTION_OBJECT__ returned from `memoize(_dco)` must always be called with the same type arguments.
* `_typeof(a1)` is __ASSIGNABLE__, __COPY_CONSTRUCTIBLE__ and __EQUALITY_COMPARABLE__.
* `_decltype(_dco(fixed, a1))` is __COPY_CONSTRUCTIBLE__.

[heading Example]
[code_memoize_example]

[heading See also]
* [@http://en.wikipedia.org/wiki/Y_combinator Fixed point combinator]

[endsect]




[section pipable]

[heading Description]
`pipable` offers a pipe-like syntax.

[heading Header]
* `<pstade/egg/pipable.hpp>`

[heading Model of]
* __OPERATABLE_OBJECT__
* __BINDABLE_OBJECT__

[heading Notation]
* `res` is an object of `result_of_pipable<_typeof(_dco)>::type` initialized using `_dco`.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`result_of_pipable<_Dco>::type`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ type]
    ]
    [
        [`PSTADE_EGG_PIPABLE_L init PSTADE_EGG_PIPABLE_R`]
        [A braced initializer of `result_of_pipable<_Dco>::type`]
    ]
    [
        [`pipable(_dco)`]
        [`res`]
    ]
    [
        [`a0|res(a1,...,aN)`]
        [`_dco(a0,...,aN)`]
    ]
]

[heading Preconditions]
* `1 <= N && N <= 5`.
* `_Dco d = init;` is a valid expression.
* The corresponding semantics is a valid expression.

[heading Invariants]
* If `_Dco` is /POD/, `result_of_pipable<_Dco>::type` is /POD/.

[heading Example]
[code_pipable_example]

[note A pipable __FUNCTION_OBJECT__ can be overloaded with different arity, whereas __AUXILIARY_INTERFACE__ cannot.]

[heading See also]
* __EGG_AUXILIARY__

[endsect]




[section ret]

[heading Description]
`ret` is akin to `boost::lambda::ret` in the context of __BOOST_RESULT_OF__.

[heading Header]
* `<pstade/egg/ret.hpp>`

[heading Model of]
* ...

[heading Notation]
* `res` is an object of `result_of_ret<_typeof(fun), Result>::type` initialized using `fun`.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`result_of_ret<Fun, Result = boost::use_default>::type`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ type]
    ]
    [
        [`PSTADE_EGG_RET_L init PSTADE_EGG_RET_R`]
        [A braced initializer of `result_of_ret<Fun, Result>::type`]
    ]
    [
        [`xp_ret<Result = boost::use_default>`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ type]
    ]
    [
        [`xp_ret<Result = boost::use_default>()(fun)`]
        [`res`]
    ]
    [
        [`res(a1,...,aN)`]
        [`fun(a1,...,aN))`]
    ]
    [
        [`egg::ret<Result>(fun)`]
        [`xp_ret<Result>()(fun)`]
    ]
]

[heading Preconditions]
* `0 <= N && N <= 5`.
* `Fun` is a __FUNCTION_OBJECT__ type.
* If `Result` is `boost::use_default`, `Fun` must be a __DEFERRED_CALLABLE_OBJECT__ type.
* `Fun f = init;` is a valid expression.
* The corresponding semantics is a valid expression.

[heading Invariants]
* If `Fun` is /POD/, `result_of_ret<Fun, Result>::type` is /POD/.

[heading Example]
...

[heading See also]
* ...

[endsect]




[section perfect]

[heading Description]
`perfect` does the "perfect forwarding".

[heading Header]
* `<pstade/egg/perfect.hpp>`

[heading Model of]
* __OPERATABLE_OBJECT__
* __BINDABLE_OBJECT__

[heading Notation]
* ...

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`result_of_perfect<_Dco>::type`]
        [`result_of_ret<_Dco>::type`]
    ]
    [
        [`PSTADE_EGG_PERFECT_L init PSTADE_EGG_PERFECT_R`]
        [`PSTADE_EGG_RET_L init PSTADE_EGG_RET_R`]
    ]
    [
        [`perfect`]
        [`xp_ret<>()`]
    ]
]

[heading Preconditions]
* The corresponding semantics is a valid expression.

[heading Invariants]
* If `_Dco` is /POD/, `result_of_perfect<_Dco>::type` is /POD/.

[heading Example]

    BOOST_CHECK( perfect(boost::lambda::_1)(12) == 12 );

[heading See also]
* ...

[endsect]




[endsect]
