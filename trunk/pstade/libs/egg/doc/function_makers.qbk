[section Function Makers]




Function makers build a "baby" function into a __FUNCTION_OBJECT__ which can be used
with `boost::lambda::bind` and `boost::resul_of`.

[import ../example/function_makers.cpp]


This section uses the following notation.

[table
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_arg(a)`]
        [`_typeof(a) const` if `a` is a rvalue; `boost::remove_reference<_decltype(a)>::type` otherwise.]
    ]
    [
        [`_ref(a)`]
        [`static_cast<_typeof(a) const &>(a)` if `a` is a rvalue; `a` otherwise.]
    ]
]




[section function]

[heading Description]
`function` is the "kernel" class template which makes a __BINDABLE__ __FUNCTION_OBJECT__ type.

[heading Header]
* `<pstade/egg/function.hpp>`

[heading Synopsys]
    template<class B>
    struct function
    {
        B b; // exposition only
        B baby() const { return b; }

        // unspecified
        // ...
    };

[heading Notation]
* `f` is an object of `function<B> const`.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`function<B>`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ /aggregate/ type]
    ]
    [
        [`f(a1,...,aN)`]
        [`f.baby().call<B::apply<_arg(a1),...,_arg(aN)>::type>(_ref(a1),...,_ref(aN))`]
    ]
    [
        [`f()`]
        [`f.baby().call<B::nullary_result_type>()`]
    ]
]

[heading Preconditions]
* The corresponding semantics is a valid expression.

[heading Invariants]
* If `B` is /POD/, `function<B>` is /POD/.

[heading Example]
[code_function_example]

[heading See also]
* __EGG_FUNCTION_BY_VALUE__
* __EGG_FUNCTION_FACADE__

[endsect]




[section function_by_value]

[heading Description]
`function` turns a rvalue argument into `const` reference, which is not acceptable to a "movable" type like `std::auto_ptr`.
`function_by_value` simply passes the arguments to the baby by value.

[heading Header]
* `<pstade/egg/function_by_value.hpp>`

[heading Synopsys]
    template<class B>
    struct function_by_value
    {
        B b; // exposition only
        B baby() const { return b; }

        // unspecified
        // ...
    };

[heading Notation]
* `f` is an object of `function_by_value<B> const`.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`function_by_value<B>`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ /aggregate/ type]
    ]
    [
        [`f(a1,...,aN)`]
        [`f.baby().call<B::apply<_typeof(a1),...,_typeof(aN)>::type>(a1,...,aN)`]
    ]
    [
        [`f()`]
        [`f.baby().call<B::nullary_result_type>()`]
    ]
]

[heading Preconditions]
* The corresponding semantics is a valid expression.

[heading Invariants]
* If `B` is /POD/, `function_by_value<B>` is /POD/.

[heading Example]
[code_function_by_value_example]

[heading See also]
* __EGG_FUNCTION__
* __EGG_FUNCTION_FACADE__

[endsect]




[section function_facade]

[heading Description]
Though a type made from `function_facade` can't be a POD type, it can have non-default constructors unlike __EGG_FUNCTION__.

[heading Header]
* `<pstade/egg/function_facade.hpp>`

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_typeof(b)`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ type]
    ]
    [
        [`b(a1,...,aN)`]
        [`static_cast<_typeof(b) const &>(b).call<_typeof(b)::apply<_arg(a1),...,_arg(aN)>::type>(_ref(a1),...,_ref(aN))`]
    ]
]

[heading Preconditions]
* `b` is an object whose type is derived from `function_facade<B>`.
* The corresponding semantics is a valid expression.

[heading Example]
[code_function_facade_example]

[heading See also]
* __EGG_FUNCTION__
* __EGG_FUNCTION_BY_VALUE__

[endsect]




[section envelope]

[heading Description]
The overload resolution system of GCC 3.4.x or below is broken when you call a function with explicit template parameter types.
If you overload `apply` in "baby" function under GCC 3.4.x, explicit template parameters must be removed using a "type envelope".

[heading Header]
* `<pstade/egg/envelope.hpp>`

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`envelope<T>`]
        [`boost::type<T>`]
    ]
]

[heading Example]
[code_envelope_example]

[note You can of course use `boost::type` instead of `envelope`, but it would be slightly less self-documenting.]

[heading See also]
* ...

[endsect]




[section adapt]
Todo
[endsect]




[section automatic]
Todo
[endsect]




[section generator]
Todo
[endsect]




[endsect]
