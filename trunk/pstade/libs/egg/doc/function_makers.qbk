[section Function Makers]




Function makers build a "baby" function into a __FUNCTION_OBJECT__ which can be used
with `boost::lambda::bind` and `boost::result_of`.

[import ../example/function_makers.cpp]


This section uses the following notation.

[table
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`_arg(a)`]
        [`_typeof(a) const` if `a` is a rvalue; `boost::remove_reference<_decltype(a)>::type` otherwise.]
    ]
    [
        [`_ref(a)`]
        [`static_cast<_typeof(a) const &>(a)` if `a` is a rvalue; `a` otherwise.]
    ]
]




[section function]

[heading Description]
`function` is the "kernel" class template which makes a __BINDABLE__ __FUNCTION_OBJECT__ type.

[heading Header]
* `<pstade/egg/function.hpp>`

[heading Synopsys]
    template<class B>
    struct function
    {
        B b; // exposition only
        B baby() const { return b; }

        // unspecified
        // ...
    };

[heading Notation]
* `f` is an object of `function<B>`.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`function<B>`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ /aggregate/ type]
    ]
    [
        [`f(a1,...,aN)`]
        [`f.baby().call<B::apply<_arg(a1),...,_arg(aN)>::type>(_ref(a1),...,_ref(aN))`]
    ]
    [
        [`f()`]
        [`f.baby().call<B::nullary_result_type>()`]
    ]
]

[heading Preconditions]
* `1 <= N && N <= _MAX_ARITY`.
* The corresponding semantics is a valid expression.

[heading Invariants]
* If `B` is /POD/, `function<B>` is /POD/.

[heading Example]
[code_function_example]

[heading See also]
* __EGG_FUNCTION_BY_VALUE__
* __EGG_FUNCTION_FACADE__

[endsect]




[section function_by_value]

[heading Description]
`function` turns a rvalue argument into `const` reference, which is not acceptable to a "movable" type like `std::auto_ptr`.
`function_by_value` simply passes the arguments to the baby by value.

[heading Header]
* `<pstade/egg/function_by_value.hpp>`

[heading Synopsys]
    template<class B>
    struct function_by_value
    {
        B b; // exposition only
        B baby() const { return b; }

        // unspecified
        // ...
    };

[heading Notation]
* `f` is an object of `function_by_value<B>`.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`function_by_value<B>`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ /aggregate/ type]
    ]
    [
        [`f(a1,...,aN)`]
        [`f.baby().call<B::apply<_typeof(a1),...,_typeof(aN)>::type>(a1,...,aN)`]
    ]
    [
        [`f()`]
        [`f.baby().call<B::nullary_result_type>()`]
    ]
]

[heading Preconditions]
* `1 <= N && N <= 10`.
* The corresponding semantics is a valid expression.

[heading Invariants]
* If `B` is /POD/, `function_by_value<B>` is /POD/.

[heading Example]
[code_function_by_value_example]

[heading See also]
* __EGG_FUNCTION__
* __EGG_FUNCTION_FACADE__

[endsect]




[section function_facade]

[heading Description]
Though a type made from `function_facade` can't be a POD type, it can have non-default constructors unlike __EGG_FUNCTION__.

[heading Header]
* `<pstade/egg/function_facade.hpp>`

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`b`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__]
    ]
    [
        [`b(a1,...,aN)`]
        [`static_cast<_typeof(b) const &>(b).call<_typeof(b)::apply<_arg(a1),...,_arg(aN)>::type>(_ref(a1),...,_ref(aN))`]
    ]
]

[heading Preconditions]
* `1 <= N && N <= _MAX_ARITY`.
* `b` is an object whose type is derived from `function_facade<B>`.
* The corresponding semantics is a valid expression.

[heading Example]
[code_function_facade_example]

[heading See also]
* __EGG_FUNCTION__
* __EGG_FUNCTION_BY_VALUE__

[endsect]




[section envelope]

[heading Description]
The overload resolution system of GCC 3.4.x or below is broken when you call the overloaded functions whose arity is the same with explicit template parameter types.
If you overload `apply` in "baby" function under GCC 3.4.x, explicit template parameters must be removed using a "type envelope".

[heading Header]
* `<pstade/egg/envelope.hpp>`

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`envelope<T>`]
        [`boost::type<T>`]
    ]
]

[heading Example]
[code_envelope_example]

[note You can of course use `boost::type` instead of `envelope`, but it would be slightly less self-documenting.]

[heading See also]
* ...

[endsect]




[section automatic]

[heading Description]
`automatic` makes a __FUNCTION_OBJECT__ type which adds automatic conversion support to a cast form function.

[heading Header]
* `<pstade/egg/automatic.hpp>`

[heading Notation]
* `u` is an object of `automatic<Lam>::type`.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`automatic<Lam>::type`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ /POD/ type]
    ]
    [
        [`PSTADE_EGG_AUTOMATIC`]
        [A braced initializer of `automatic<Lam>::type`]
    ]
    [
        [`To to = u(a1,...,aN);`]
        [`To to = boost::mpl::apply<Lam, To>::type(_ref(a1),..,_ref(aN));`]
    ]
    [
        [`To to = u();`]
        [`To to = boost::mpl::apply<Lam, To>::type();`]
    ]
]

[heading Preconditions]
* `Lam` is an __MPL_LAMBDA_EXPRESSION__.
* `1 <= N && N <= _MAX_ARITY`.
* `boost::mpl::apply<Lam, To>::type` is a __DEFERRED_CALLABLE_OBJECT__ type.
* The corresponding semantics is a valid expression.
* `u` is not placed in a default argument list.

[note These valid expressions imply that the automatic deduction is available everywhere /copy-initialization/ is invoked.
      For example, you can place `u` in /return-statement/. The last precondition comes from a bug of GCC.]

[heading Example]
[code_automatic_example]

[heading See also]
* ...

[endsect]




[section deferred]

[heading Description]
`deferred` is an emulation of `boost::detail::functionN` family.

[heading Header]
* `<pstade/egg/deferred.hpp>`

[heading Notation]
* `f` is an object of `deferred<Lam>::type`.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`deferred<Lam>::type`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ /POD/ type]
    ]
    [
        [`PSTADE_EGG_DEFERRED`]
        [A braced initializer of `deferred<Lam>::type`]
    ]
    [
        [`f(a1,...,aN)`]
        [`boost::add_const<boost::mpl::apply<Lam, _arg(a1),...,_arg(aN)>::type>::type()(_ref(a1),...,_ref(aN))`]
    ]
    [
        [`PSTADE_EGG_DEFER((Lam))`]
        [`deferred<Lam>::type` with a msvc-8.0 workaround]
    ]
]

[heading Preconditions]
* `Lam` is an __MPL_LAMBDA_EXPRESSION__.
* `1 <= N && N <= _MAX_ARITY`.
* `boost::mpl::apply<Lam, _arg(a1),...,_arg(aN)>::type::result_type` is a valid expression.
* The corresponding semantics is a valid expression.
* `PSTADE_EGG_DEFER` is placed in namespace scope.

[caution msvc-8.0 randomly fails to make `deferred<Lam>::type` be a __DEFERRED_CALLABLE_OBJECT__ in deduced context.
         Prefer `PSTADE_EGG_DEFER` if you need portability.]

[heading Example]
[code_deferred_example]

[heading See also]
* ...

[endsect]




[section generator]

[heading Description]
`generator` makes an "object generator".

[heading Header]
* `<pstade/egg/generator.hpp>`

[heading Notation]
* `g` is an object of `generator<Lam>::type`.

[heading Valid expressions]
[table 
    [
        [[*Valid expression]]
        [[*Semantics]]
    ]
    [
        [`generator<Lam>::type`]
        [A __BINDABLE__ __DEFERRED_CALLABLE_OBJECT__ /POD/ type]
    ]
    [
        [`PSTADE_EGG_GENERATOR`]
        [A braced initializer of `generator<Lam>::type`]
    ]
    [
        [`g(a1,...,aN)`]
        [`boost::mpl::apply<Lam, _arg(a1),...,_arg(aN)>::type(_ref(a1),...,_ref(aN))`]
    ]
    [
        [`deduce<A, Ded>`]
        [` boost::mpl::apply<Ded, A>` if the corresponding argument is passed; ill-formed otherwise.]
    ]
    [
        [`deduce<A, Ded, Def>`]
        [` boost::mpl::apply<Ded, A>` if the corresponding argument is passed; `boost::mpl::identity<Def>` otherwise.]
    ]
    [
        [`as_value::apply<A>`]
        [`boost::remove_const<boost::decay<A>::type>`]
    ]
    [
        [`as_reference::apply<A>`]
        [`boost::add_reference<A>`]
    ]
    [
        [`as_qualified::apply<A>`]
        [`boost::mpl::identity<A>`]
    ]
]

[heading Preconditions]
* `Lam` is an (possibly /cv-qualified/) __MPL_LAMBDA_EXPRESSION__.
* `1 <= N && N <= _MAX_ARITY`.
* The corresponding semantics is a valid expression.

[note `Lam` is not instantiated while invoking `boost::mpl::apply`, so that any static assertion in generated type doesn't fail.]

[heading Example]
[code_generator_example]

[heading See also]
* ...

[endsect]




[endsect]
